Zookeeper 是一个典型的发布/订阅模式的分布式数据管理与协调框架，开发人员 可以使用它来进行分布式数据的发布和订阅。
通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机 制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：
1、数据发布/订阅 
2、负载均衡 
3、命名服务 
4、分布式协调/通知 
5、集群管理 
6、Master 选举 
7、分布式锁 
8、分布式队列

# 1数据发布、订阅

数据（配置信息）特性
1、数据量通常比较小 
2、数据内容在运行时会发生动态更新 
3、集群中各机器共享，配置一致
如：机器列表信息、运行时开关配置、数据库配置信息等

基于ZK实现方式
* 数据存储：将数据（配置信息）存储到Zookeeper上的一个数据节点 
*  数据获取：应用在启动初始化节点从Zookeeper数据节点读取数据，并 在该节点上注册一个数据变更Watcher 
* 数据变更：当变更数据时，更新Zookeeper对应节点数据，Zookeeper 会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即 可。

Zookeeper 分布式锁（文件系统、通知机制）
有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类， 一个是保持独占，另一个是控制时序。
对于第一类，我们将 zookeeper上的一个 znode看作是一把锁，通过 createznode 的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那 个客户端也即拥有了这把锁。用完删除掉自己创建的 distribute_lock 节点就释放 出锁。 
对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺 序编号目录节点，和选 master 一样，编号最小的获得锁，用完删除，依次方便。

Zookeeper选举机制
当 Zookeeper 集群中的一台服务器出现以下两种情况之一时，需要进入 Leader 选举。
    （1）服务器初始化启动。
    （2）服务器运行期间 Leader 故障。
    全新集群选举策略：
    目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：
    服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking(选举状态)。
    服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。
    服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟。
    服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟。
    服务器5启动，后面的逻辑同服务器4成为小弟。
    非全新集群选举策略：
    对于运行正常的 zookeeper 集群，中途有机器 down 掉，需要重新选举时， 选举过程就需要加入数据 ID、服务器 ID 和逻辑时钟。
    事务 ID（Zxid）:服务器中存放的数据的事务ID，值越大说明数据越新，在选举算法中数据越新权重越大。
    服务器 ID:就是我们配置的 myid 中的值，每个机器一个。
    逻辑时钟:或者叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。
    1、如果服务器B接收到服务器A的数据（服务器A处于选举状态(LOOKING 状态)
     1）首先，判断逻辑时钟值：
　　　　a）如果发送过来的逻辑时钟Epoch大于目前的逻辑时钟。首先，更新本逻辑时钟Epoch，同时清空本轮逻辑时钟收集到的来自其他server的选举数据。然后，判断是否需要更新当前自己的选举leader Serverid。判断规则rules judging：保存的zxid最大值和leader Serverid来进行判断的。先看数据zxid,数据zxid大者胜出;其次再判断leader Serverid,leader Serverid大者胜出；然后再将自身最新的选举结果(也就是上面提到的三种数据（leader Serverid，Zxid，Epoch）广播给其他server)
　　　　b）如果发送过来的逻辑时钟Epoch小于目前的逻辑时钟。说明对方server在一个相对较早的Epoch中，这里只需要将本机的三种数据（leader Serverid，Zxid，Epoch）发送过去就行。
　　　　c）如果发送过来的逻辑时钟Epoch等于目前的逻辑时钟。再根据上述判断规则rules judging来选举leader ，然后再将自身最新的选举结果(也就是上面提到的三种数据（leader  Serverid，Zxid，Epoch）广播给其他server)。
    2）其次，判断服务器是不是已经收集到了所有服务器的选举状态：若是，根据选举结果设置自己的角色(FOLLOWING还是LEADER)，退出选举过程就是了。
最后，若没有收到没有收集到所有服务器的选举状态：也可以判断一下根据以上过程之后最新的选举leader是不是得到了超过半数以上服务器的支持,如果是,那么尝试在200ms内接收一下数据,如果没有新的数据到来,说明大家都已经默认了这个结果,同样也设置角色退出选举过程。
  2、 如果所接收服务器A处在其它状态（FOLLOWING或者LEADING）
　　　　a)逻辑时钟Epoch等于目前的逻辑时钟，将该数据保存到recvset。此时Server已经处于LEADING状态，说明此时这个server已经投票选出结果。若此时这个接收服务器宣称自己是leader, 那么将判断是不是有半数以上的服务器选举它，如果是则设置选举状态退出选举过程。
　　　　b) 否则这是一条与当前逻辑时钟不符合的消息，那么说明在另一个选举过程中已经有了选举结果，于是将该选举结果加入到outofelection集合中，再根据outofelection来判断是否可以结束选举,如果可以也是保存逻辑时钟，设置选举状态，退出选举过程。