Zookeeper 是一个典型的发布/订阅模式的分布式数据管理与协调框架，开发人员 可以使用它来进行分布式数据的发布和订阅。
通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机 制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：
1、数据发布/订阅 
2、负载均衡 
3、命名服务 
4、分布式协调/通知 
5、集群管理 
6、Master 选举 
7、分布式锁 
8、分布式队列

# 1数据发布、订阅

数据（配置信息）特性
1、数据量通常比较小 
2、数据内容在运行时会发生动态更新 
3、集群中各机器共享，配置一致
如：机器列表信息、运行时开关配置、数据库配置信息等

基于ZK实现方式
* 数据存储：将数据（配置信息）存储到Zookeeper上的一个数据节点 
*  数据获取：应用在启动初始化节点从Zookeeper数据节点读取数据，并 在该节点上注册一个数据变更Watcher 
* 数据变更：当变更数据时，更新Zookeeper对应节点数据，Zookeeper 会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即 可。

Zookeeper 分布式锁（文件系统、通知机制）
有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类， 一个是保持独占，另一个是控制时序。
对于第一类，我们将 zookeeper上的一个 znode看作是一把锁，通过 createznode 的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那 个客户端也即拥有了这把锁。用完删除掉自己创建的 distribute_lock 节点就释放 出锁。 
对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺 序编号目录节点，和选 master 一样，编号最小的获得锁，用完删除，依次类推。

zookeeper 与kafka保持数据一致性的不同点：
(1)zookeeper使用了ZAB(Zookeeper Atomic Broadcast)协议，保证了leader,follower的一致性，leader 负责数据的读写，而follower只负责数据的读，如果follower遇到写操作，会提交到leader;
当leader宕机的话，使用 Fast Leader Election 快速选举出新的leader,节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。
其客户端根据链接的follower不同，可能读取到不同的数据。这是由于副本没有完全同步，存在时间差的原因。由于follower分担了读取数据的压力，zookeeper只要保留全局leader即可，不再进行细分。

(2)kafka 不同，只有leader 负责读写，follower只负责备份，如果leader宕机的话,Kafaka动态维护了一个同步状态的副本的集合（a set of in-sync replicas），简称ISR,ISR中有f+1个节点，就可以允许在f个节点down掉的情况下不会丢失消息并正常提供服。ISR的成员是动态的，如果一个节点被淘汰了，当它重新达到“同步中”的状态时，他可以重新加入ISR。因此如果leader宕了，直接从ISR中选择一个follower就行。

Zookeeper选举机制
当 Zookeeper 集群中的一台服务器出现以下两种情况之一时，需要进入 Leader 选举。
    （1）服务器初始化启动。
    （2）服务器运行期间 Leader 故障。
    全新集群选举策略：
    目前有4台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,按编号依次启动，它们的选择举过程如下：
    服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking(选举状态)。
    服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数大于半数，所以服务器2成为领导者，服务器1成为小弟
    服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器2已经是领导者，所以直接将自己的角色变为小弟。
    服务器4启动，后面的逻辑同服务器3成为小弟。
    非全新集群选举策略：
    对于运行正常的 zookeeper 集群，中途有机器 down 掉，需要重新选举时， 选举过程就需要加入数据 ID、服务器 ID 和逻辑时钟。
    事务 ID（Zxid）:服务器中存放的数据的事务ID，值越大说明数据越新，在选举算法中数据越新权重越大。
    服务器 ID(sid):就是我们配置的 myid 中的值，每个机器一个。
    逻辑时钟:或者叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。
    成为 Leader 的条件：
    1）选 epoch 最大的
    2）若 epoch 相等，选 zxid 最大的
    3）若 epoch 和 zxid 相等，选择 server_id 最大的（zoo.cfg中的myid）


如果leader 节点宕机，在恢复后它还能被选为leader吗？
不能，因为会重新选举(选举期间暂停对外服务，直到新的leader产生)，然后再次加进来，原来的leader会跟新的leader进行数据同步，变成follwer

现在有三个节点， zk1,zk2,zk3， zk2是leader，zk2挂了的同时在zk1进行了delete操作，现在把zk1 和 zk3也挂掉，再把三个节点全部起来，那么现在zk2还是leader嘛？
不是。 因为你leader挂了之后，就会选举出新的leader(zk3)，此时你在zk1中更新的数据（delete了一条数据）此时zk1和zk3的zxid是一致的，已经同步呢！
(你老的leader(zk2)中的数据不是最新的，怎么好意思再给follower同步数据呢！)
现在你又把zk1和zk3挂掉，再重启zk1,zk2,zk3，此时的选举，不再是一开始根据myid谁大谁就是leader，而是基于zxid(节点的事物ID)谁大谁就是leader，因为zk1更新了数据，此时它的zxid是最大的，所以启动后zk1是leader
最后集群状态一致的话，整个集群的zxid都会一样



ZAB 协议两种基本的模式：
崩溃恢复和消息广播
当整个 zookeeper 集群刚刚启动或者 Leader 服务器宕机、重启或者网络故障导

致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进

入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务

器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader

服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始

接收客户端的事务请求生成事物提案来进行事务请求处理。


集群支持动态添加机器吗？
其实就是水平扩容了，Zookeeper 在这方面不太好。两种方式：
全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的会话。
逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供
服务。这是比较常用的方式。

