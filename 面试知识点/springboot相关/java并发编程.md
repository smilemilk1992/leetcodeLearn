1、在java中 守护线程和本地线程区别

    唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，
    如果 全部的 User Thread 已经撤离，Daemon 没有可服务的线程，
    JVM 撤离。也可 以理解为守护线程是 JVM 自动创建的线程（但不一定），
    用户线程是程序创建的 线程；比如 JVM 的垃圾回收线程是一个守护线程，
    当所有线程已经撤离，不再产 生垃圾，守护线程自然就没事可干了，
    当垃圾回收线程是 Java 虚拟机上仅剩的线 程时，Java 虚拟机会自动离开。

2、线程与进程区别
    
    进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。
    一个程序至少有一个进程,一个进程至少有一个线程。

3、什么是多线程中的上下文切换

    多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU数量时， 
    为了让各个线程都有执行的机会，就需要轮转使用 CPU。
    不同的线程切换使用 CPU 发生的切换数据等就是上下文切换。

4、Java中用到的线程调度算法是什么？
    
    采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优 先级上，如非特别需要，尽量不要用，防止线程饥饿。

5、Lock 与 synchronized区别

    synchronized、ReentrantLock 都是可重入的锁，可重入锁相对来说简化了并发 编程的开发。

     * 　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
     *
     * 　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
     *
     * 　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
     *
     * 　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
     *
     * 　5）Lock可以提高多个线程进行读操作的效率。
     *
     * 在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态。
     
     整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的 (tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多 条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平 锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非 公平锁是高效的选择。
    非公平锁的实现在刚开始获取锁的时候，直接使用了一次CAS去尝试获取锁，不成功才会构建node节点。而在公平锁中会首先判断是否已经有等待中的线程。这就是公平锁与非公平锁的差异所在。
    
    1.非公平锁在调用lock后，会首先进行CAS抢锁，如果这个时候抢占到了，就直接返回true了
    2.相对来说，非公平所性能会比较好一点，吞吐量比较大。

6、在Java中CycliBarriar和CountdownLatch有什么区别？

    * CyclicBarrier是java推出的一个并发编程工具，它用在多个线程之间协同工作，CyclicBarrier 一个同步辅助类。
    * 线程约定到达某个点，到达这个点之后的线程都停下来，直到最后一个线程也到达了这个点之后，所有的线程才会得到释放。常用的场景是：多个worker线程，每个线程都在循环地做一部分工作，并在最后用cyclicBarrier.await()设下约定点，当最后一个线程做完了工作也到达约定点后，所有线程得到释放，开始下一轮工作
    Java 的 concurrent 包里面的 CountDownLatch 其实可以把它看作一个计数器， 只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器， 也就是同时只能有一个线程去减这个计数器里面的值。 你可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个 对象上的 await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为 0 为 止。
    CyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用。

7、java中有几种方法可以实现一个线程？

    继承 Thread 类 实现 Runnable 接口 实现 Callable 接口，需要实现的是 call() 方法

8、乐观锁和悲观锁

    悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每 次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传 统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写 锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关 键字的实现也是悲观锁。
    乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所 以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据， 可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量， 像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实 现方式 CAS 实现的。
    乐观锁的实现方式： 1、使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标 识，不一致时可以采取丢弃和再次尝试的策略。 2、java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新 同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的 线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作 中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A） 和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自 动将该位置值更新为新值 B。否则处理器不做任何操作。

    CAS 缺点：
    1、ABA 问题： 
    比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中 取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A， 这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线 程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。
   
    2、循环时间长开销大： 
    对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪 费更多的 CPU 资源，效率低于 synchronized。 
    
    3、只能保证一个共享变量的原子操作： 
    当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作， 但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可 以用锁。

9、SynchronizedMap和ConcurrentHashMap有什么区别？

    SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来 访为 map。
    ConcurrentHashMap 使用分段锁来保证在多线程下的性能。 
    ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。 
    这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提 升是显而易见的。 

10、volatile有什么用？能否用一句话说明下volatile的应用场景？

    volatile 保证内存可见性和禁止指令重排。
    volatile 用于多线程环境下的单次操作(单次读或者单次写)。
    像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。


11、Java如何在两个线程之间共享数据？

    Java 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。Java
    内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。

12、Java中notify 和 notifyAll有什么区别？

    notify() 方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有 用武之地。而 notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程 能继续运行。

13、为什么wait, notify 和 notifyAll这些方法不在thread类里面？

    一个很明显的原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有 锁，通过线程获得。由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他 们定义在 Object 类中因为锁属于对象。

14、java中的Semaphore是什么

     * Semaphore就可以用于控制并发线程数量
     * 常常被当做限流用
     
     RateLimiter翻译过来是速率限制器，使用的是一种叫令牌桶的算法，当线程拿到桶中的令牌时，才可以执行。通过设置每秒生成的令牌数来控制速率。

15、Java线程池中submit() 和 execute()方法有什么区别？

    两个方法都可以向线程池提交任务，execute()方法的返回类型是 void，它定义在 Executor 接口中。
    而 submit()方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，
    其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。

16、volatile 变量和 atomic 变量有什么不同？

    Volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不 能保证原子性。例如用 volatile 修饰 count 变量那么 count++ 操作就不是原子 性的。
    而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如 getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型 和引用变量也可以进行相似操作。

17、为什么wait(), notify()和notifyAll ()必须在同步方法或者同步块中被调用？

    当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接 着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify() 方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的 锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要 线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者 同步块中被调用。
    
18、并发编程的三要素

    1、原子性 原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操 作打断，要么就全部都不执行。 
    2、可见性 可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他 线程可以立即看到修改的结果。 
    3、有序性 有序性，即程序的执行顺序按照代码的先后顺序来执行。

19、实现可见性的方法有哪些？

    synchronized 或者 Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放 之前把最新的值刷新到主内存，实现可见性。

20、创建线程的有哪些方式？

    1、继承 Thread 类创建线程类 
    2、通过 Runnable 接口创建线程类 
    3、通过 Callable 和 Future 创建线程 
    4、通过线程池创建

21、四种线程池的创建

    1、newCachedThreadPool 创建一个可缓存线程池 
    2、newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数。 
    3、newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执 行。 
    4、newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工 作线程来执行任务。

22、线程池的优点

    1、重用存在的线程，减少对象创建销毁的开销。 
    2、可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞 争，避免堵塞。 
    3、提供定时执行、定期执行、单线程、并发数控制等功能。

23、常用的并发工具类有哪些？

    1、CountDownLatch 
    2、CyclicBarrier 
    3、Semaphore 
    4、Exchanger

24、CyclicBarrier和CountDownLatch的区别
    
    1、CountDownLatch 简单的说就是一个线程等待，直到他所等待的其他线程都执 行完成并且调用 countDown()方法发出通知后，当前线程才可以继续执行。
    2、cyclicBarrier 是所有线程都进行等待，直到所有线程都准备好进入 await()方 法之后，所有线程同时开始执行！ 
    3、CountDownLatch 的计数器只能使用一次。而 CyclicBarrier 的计数器可以使 用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务场景，比如如果 计算发生错误，可以重置计数器，并让线程们重新执行一次。 
    4、CyclicBarrier 还提供其他有用的方法，比如 getNumberWaiting 方法可以获 得 CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。 如果被中断返回 true，否则返回 false
    
25、Java 中，编写多线程程序的时候你会遵循哪些最佳实践？

    这是我在写 Java 并发程序的时候遵循的一些最佳实践： 
    a）给线程命名，这样可以帮助调试。 
    b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。 
    c）如果可以，更偏向于使用 volatile 而不是 synchronized。 
    d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通 信，如 BlockingQueue，CountDownLatch 及 Semeaphore。 
    e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。

26、线程池的工作原理，几个重要参数，然后给了具体几个参数分析线程池会怎么做，最后问阻塞队列会怎么做
