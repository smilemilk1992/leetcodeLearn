实战：
# redis-https://www.cnblogs.com/2020-zhy-jzoj/p/13164739.html
1、有没有遇到什么坑

    业务端一般认为redis出现问题，就是redis云有问题，人的“正常”思维：看别人错误容易，发现自己难，扯多了, 出现这个有很多原因：
       (1). 网络原因：比如是否存在跨机房、网络割接等等。
       (2). 慢查询，因为redis是单线程，如果有慢查询的话，会阻塞住之后的操作。 
       (3). value值过大？比如value几十兆，当然这种情况比较少，其实也可以看做是慢查询的一种
       (4). aof重写/rdb fork发生？瞬间会堵一下Redis服务器。
2、redis主从同步过程

    1.从服务发送一个sync同步命令给主服务要求全量同步。
    2.主服务接收到从服务的sync同步命令时，会fork一个子进程后台执行bgsave命令（非阻塞）快照保存，生成RDB文件，并将RDB文件发送给从服务。
    3.从服务再将接收到的RDB文件载入自己的redis内存。
    4.待从服务将RDB载入完成后，主服务再将缓冲区所有写命令发送给从服务。
    5.从服务在将主服务所有的写命令载入内存从而实现数据的完整同步。
    6.从服务下次在需要同步数据时只需要发送自己的offset位置（相当于MySQL binlog的位置）即可，只同步新增加的数据，再不需要全量同步。
    主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。

3、redis哨兵机制-https://www.jianshu.com/p/3677afe376ee

    哨兵(Sentinel)主要是为了解决在主从复制架构中出现宕机的情况,是建立在主从模式的基础上面的
    Redis-Sentinel是Redis官方推荐的高可用（HA）方案，当用Reids 做master-slave高可用方案时，假如master宕机了，redis本身（包括它的很多客服端）都没有实现自动的主备切换，而Redis-Sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能自动切换。



4、redis原理，跳表的时间复杂度

    Redis 是一款基于 ANSI C 语言编写的，BSD 许可的，日志型 key-value 存储组件，它的所有数据结构都存在内存中，可以用作缓存、数据库和消息中间件。
    redis是nosql(也是个巨大的map) 单线程，但是可处理1秒10w的并发（数据都在内存中）
    跳表其实是多条链表组成的链表结构，其特点在于查询时能够跳跃式查询。其复杂度取决于链表的跳跃区间的离散程度。


5、redis集群模式

    * 主从模式（主从模式的弊端就是不具备高可用性，当master挂掉以后，Redis将不能再对外提供写入操作）
        * 主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库
        * 从数据库一般都是只读的，并且接收主数据库同步过来的数据
        * 一个master可以拥有多个slave，但是一个slave只能对应一个master
        * slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来
        * master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务
        * master挂了以后，不会在slave节点中重新选一个master
        * 可以实现读写分离，数据备份。但是并不是「高可用」的
    
    * Sentinel模式
        * sentinel模式是建立在主从模式的基础上，如果只有一个Redis节点，sentinel就没有任何意义
        * 当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master
        * 当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据
        * sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群
        * 多sentinel配置的时候，sentinel之间也会自动监控
        * 当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中，不需要担心
        * 一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis
        * sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也挂了
        * Redis哨兵模式实现了高可用，读写分离，但是其主节点仍然只有一个，即写入操作都是在主节点中，这也成为了性能的瓶颈。
    * 集群模式
        * Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽， 集群的每个节点负责一部分 hash 槽。
        * 集群至少需要3主3从
        * 不仅提供了高可用的手段，同时数据是分片保存在各个节点中的，可以支持高并发的写入与读取。当然实现也是其中最复杂的。
        


6、redis雪崩和穿透怎么解决-https://zhuanlan.zhihu.com/p/58331707  https://www.cnblogs.com/liluxiang/p/10320491.html

    血崩：
    1、redis集群大面积故障
    2、缓存失效，但依然大量请求访问缓存服务redis
    3、redis大量失效后，大量请求转向到mysql数据库
    4、mysql的调用量暴增，很快就扛不住了，甚至直接宕机
    5、由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。
    
    如何解决：
    1、缓存高可用
    2、缓存降级
    3、Redis备份和快速预热
    4、提前演练
    
    穿透：
    缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。
    
    解决：
    如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。

    可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。
    
7、热点缓存问题-https://www.cnblogs.com/xuwc/p/14013060.html

    热key问题，指的就是缓存集群中的某个key在瞬间被数万甚至十万的并发请求打爆。大value问题，指的是某个key对应的value可能有gb级别的大小，导致查询value的时候会引发网络相关的故障问题。这里说一下热key问题。
    所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。
    那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。

    发现热key:
    1、凭借业务经验，进行预估哪些是热key
    2、在客户端进行收集
    3、在Proxy层做收集
    4、用redis自带命令
    
    如何解决：
    1、利用二级缓存
    比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。
    针对这种热key请求，会直接从jvm中取，而不会走到redis层。
    假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。
    现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。
    2、备份热key
    这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。
    3、监控热key
    4、通知系统做处理

# hashmap
1、HashMap内部怎么实现的

    HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。
    简单来说，HashMap由数组+链表+红黑树组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。
    
2、Hashmap扩容做了什么操作，为什么要扩容成两倍

    扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；
    
    HashMap的初始容量是2的n次幂，扩容也是2倍的形式进行扩容，是因为容量是2的n次幂，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低！
    
3、HashMap的put操作过程
 思路如下：
 
    1、如果HashMap没有被初始化过，则初始化
    2、对key求Hash值，然后在计算下标
    3、如果没有碰撞则直接放入桶中
    4、如果碰撞了，以链表的方式链接到后面（尾插法）
    5、如果链表长度超过阈值8，就把链表转为红黑树
    6、如果链表长度低于6，就把红黑树转回链表
    7、如果节点已经存在就替换旧值
    8、如果桶满了（16*加载因子0.75）， 就需要resize（扩容两倍后重排-位置不变或索引+旧容量大小）

4、hashmap线程不安全的体现

    1.在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。
    2.在jdk1.8中，在多线程环境下，会发生数据覆盖的情况。

#多线程
1、线程池拒绝策略

    1、AbortPolicy-直接抛出拒绝异常（继承自RuntimeException），会中断调用者的处理过程，所以除非有明确需求，一般不推荐
    2、CallerRunsPolicy-在调用者线程中（也就是说谁把 r 这个任务甩来的），运行当前被丢弃的任务。只会用调用者所在线程来运行任务，也就是说任务不会进入线程池。如果线程池已经被关闭，则直接丢弃该任务
    3、DiscardOledestPolicy-丢弃队列中最老的，然后再次尝试提交新任务。
    4、DiscardPolicy-默默丢弃无法加载的任务，不抛出异常。
    
2、volatile的原理
    
    volatile可见性：对一个volatile的读，总可以看到对这个变量最终的写；
    volatile原子性：volatile对单个读/写具有原子性（32位Long、Double），但是复合操作除外，例如：i++；
    jvm底层采用“内存屏障”来实现volatile语义。
    volatile的内存语义及实现：
        在JMM中，线程之间的通信采用共享内存来实现的。
    volatile内存语义是：

        当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新到主内存中；
        当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量。
    
    volatile的底层实现是通过插入内存屏障，但是对于编译器来说，发现一个最优布置来最小化插入内存屏障的总数几乎是不可能的，所以，JMM采用保守策略。如下：
    
        在每一个volatile写操作前面插入一个StoreStore屏障
        在每一个volatile写操作后面插入一个StoreLoad屏障
        在每一个volatile读操作后面插入一个LoadLoad屏障
        在每一个volatile读操作后面插入一个LoadStore屏障
    StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中；
    StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序
    LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序
    LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序
    
    java中volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。
    
    在java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：
    
    1、volatile关键字会禁止指令重排；
    2、synchronized关键字保证同一时刻只允许一条线程操作。 synchronized是万能，他可以同时满足三种特性，这其实也是很多人滥用synchronized的原因。
        
    
3、	线程安全的场景和如何保证

    一般来说如果一个类有自己的可变状态，如成员变量，类变量，并且这些会在执行过程中改变它的值，那么就要考虑线程安全。
    
    如何保证：
    不在线程之间共享状态变量
    将状态变量修改成不可变的变量
    在访问状态变量时使用同步 
    加锁
        

#spring-https://zhuanlan.zhihu.com/p/266901018

```text
依旧以上面A、B类使用属性field注入循环依赖的例子为例，对整个流程做文字步骤总结如下：
使用context.getBean(A.class)，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走A的创建之路~
实例化A（注意此处仅仅是实例化），并将它放进缓存（此时A已经实例化完成，已经可以被引用了）
初始化A：@Autowired依赖注入B（此时需要去容器内获取B）
为了完成依赖注入B，会通过getBean(B)去容器内找B。但此时B在容器内不存在，就走向B的创建之路~
实例化B，并将其放入缓存。（此时B也能够被引用了）
初始化B，@Autowired依赖注入A（此时需要去容器内获取A）
此处重要：初始化B时会调用getBean(A)去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以getBean(A)能够正常返回
B初始化成功（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中~）。
因为B实例已经成功返回了，因此最终A也初始化成功
到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~
```
1、springboot 如何解决循环依赖？

    多个实例之间的相互依赖关系构成一个环形，就是循环依赖
    1、重新设计
        重新设计结构，消除循环依赖。
    2、使用注解@Lazy
        一种最简单的消除循环依赖的方式是通过延迟加载。在注入依赖时，先注入代理对象，当首次使用时再创建对象完成注入。
    3、使用Setter/Field注入
        Spring文档建议的一种方式是使用setter注入。当依赖最终被使用时才进行注入

2、循环依赖会出现什么问题？

    1、循环依赖会产生多米诺骨牌效应
        难以为代码编写测试，因为易变导致写的测试也不稳定
        难以重构，因为互相依赖，你改动一个自然会影响其他依赖对象
        难以维护，你根本不敢想象你的改动会造成什么样的后果
    2、循环依赖会导致内存溢出
    
3、spring循环依赖为什么用三级缓存-https://www.cnblogs.com/semi-sub/p/13548479.html

测试证明，二级缓存也是可以解决循环依赖的。为什么 Spring 不选择二级缓存，而要额外多添加一层缓存呢？

如果 Spring 选择二级缓存来解决循环依赖的话，那么就意味着所有 Bean 都需要在实例化完成之后就立马为其创建代理，而 Spring 的设计原则是在 Bean 初始化完成之后才为其创建代理。所以，Spring 选择了三级缓存。但是因为循环依赖的出现，导致了 Spring 不得不提前去创建代理，因为如果不提前创建代理对象，那么注入的就是原始对象，这样就会产生错误。

我们可以知道 Spring 需要三级缓存的目的是为了在没有循环依赖的情况下，延迟代理对象的创建，使 Bean 的创建符合 Spring 的设计原则。

Spring 解决循环依赖的核心就是提前暴露对象，而提前暴露的对象就是放置于第二级缓存中

| 名称	| 描述 |
| singletonObjects |	一级缓存，存放完整的 Bean。
| earlySingletonObjects |	二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。|
| singletonFactories | 三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。 |

    Spring 是如何通过上面介绍的三级缓存来解决循环依赖的呢？这里只用 A，B 形成的循环依赖来举例：
    实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。
    为 A 创建一个 Bean 工厂，并放入到 singletonFactories 中。
    发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。
    实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。
    为 B 创建一个 Bean 工厂，并放入到 singletonFactories 中。
    发现 B 需要注入 A 对象，此时在一级、二级未发现对象 A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A 还是一个半成品，并没有完成属性填充和执行初始化方法）
    将对象 A 注入到对象 B 中。
    对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）
    对象 A 得到对象 B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）
    对象 A 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。
    
4、spring的bean是怎么管理的

    在Spring框架中，一旦把一个bean纳入到Spring IoC容器之中，这个bean的生命周期就会交由容器进行管理，一般担当管理者角色的是BeanFactory或ApplicationContext
    bean对象的生命周期
    1.单例对象（singleton时）
    (1)创建：容器创建时，对象创建。（加载完beans配置文件，对象也就创建了）
    (2)生存：只要容器还在，对象也一直存在。
    (3)消亡：容器销毁，对象消亡。
    总结：单例对象，与容器共存亡。
    
    2.多例对象（singleton时）
    (1)创建：当我们使用对象时，spring框架为我们创建。
    (2)生存：对象只要是在使用过程中就一直存在。
    (3)消亡：对象长时间不用，且没有别的对象引用时，由Java回收机制（GC）回收。
    总结：多例对象，与正常new出来的Java对象的生命周期一样。

5、applicationContext和beanFactory的区别

    ApplicationContext是继承了 BeanFactory 接口 所以 ApplicationContext 包含 BeanFactory 的所有功能以及更多功能
    BeanFactory：bean工厂接口；负责创建bean实例；容器里面保存的所有单例bean其实是一个map；Spring最底层的接口
    ApplicationContext：是容器接口；更多负责容器功能的实现；（可以基于BeanFactory创建好的对象之上完成强大的容器）
    容器可以从map中获取这个bean，并且可以进行aop、di等操作
    BeanFactory是最底层的接口，ApplicationContext留给程序员使用的ioc容器接口；ApplicationContext是BeanFactory的子接口
    ----------------------------------------
    BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。
    BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。
    从表面上看，ApplicationContext如同BeanFactory 一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但ApplicationContext在此基础上还提供了其他的功能。
    1.提供了支持国际化的文本消息
    2.统一的资源文件读取方式
    3.已在监听器中注册的bean的事件


#锁-https://zhuanlan.zhihu.com/p/139021371 https://www.jianshu.com/p/17be890865e7?utm_campaign=maleskine
1、偏向锁、轻量级锁、自旋锁、重量级锁的转化

7、偏向锁/轻量级锁/重量级锁：

    这三种锁的状态是针对Synchronized而引入的，通过对象监控在对象头中的字段来表明状态
    偏向锁：指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价
    轻量级锁：指当锁是偏向锁时，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能
    重量级锁：指当锁是轻量级锁时，另一个线程虽然自旋，但自旋不会一直持续下去，当自旋到一定次数时，还没获取到锁，就会进入阻塞，该锁膨胀为重量级锁，重量级锁会让其他申请的线程进入阻塞，性能降低
    8、自旋锁：
    自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU

2、读写锁的实现原理

    读写锁的特点是：同一时刻允许多个线程对共享资源进行读操作；同一时刻只允许一个线程对共享资源进行写操作；当进行写操作时，同一时刻其他线程的读操作会被阻塞；当进行读操作时，同一时刻所有线程的写操作会被阻塞。对于读锁而言，由于同一时刻可以允许多个线程访问共享资源，进行读操作，因此称它为共享锁；而对于写锁而言，同一时刻只允许一个线程访问共享资源，进行写操作，因此称它为排他锁。
    读写锁不支持锁升级，支持锁降级。锁升级指的是线程获取到了读锁，在没有释放读锁的前提下，又获取写锁。锁降级指的是线程获取到了写锁，在没有释放写锁的情况下，又获取读锁。
     读写锁同时拥有读锁和写锁，且读共享、写及读写互斥， 当读取数据时用读锁，当没有线程获取到写锁或获取写锁是当前线程时能获取到读锁，多个线程可同时获取到读锁；当写数据时用写锁，当没有线程获取到读锁时，可以获取到写锁，最多只有一个线程能获取到写锁，若当前线程获取到读锁必须要先释放才能获取到写锁。
     
     基于AQS（抽象队列同步器，有一个voliate int state变量和互斥/共享获取、释放锁方法），Java 读写锁用state的高16位表示读锁的线程数，低16位表示写锁的重入数。其中读锁类中的Sync实现共享获取、释放锁方法，写锁类中Sync实现互斥获取、释放锁方法。
     
3、Aqs原理

4、CAS原理

#mysql数据库
1、数据库索引为什么用B+树
2、分库分表场景
3、慢查询场景

# 消息队列
1、RocketMq的事务消息是怎么实现的
2、kafka与mq对比
3、RabbitMq怎么保证消息的可靠性
4、Kafka为什么可以保证extraclyOnece
5、Kafka怎么保证的高并发高可用

# JVM调优-https://www.jianshu.com/p/0e32d7b4c064
1、CMS和G1回收算法的过程
2、Outofmemory的场景
3、FullGC和OutOfMemory有什么区别，怎么排查
4、Jvm调优的工具和命令
5、服务响应慢怎么排查

# 其他
1、以前工作中难度最高和提升最大的项目
2、复合索引的数据结构
3、可重复读的实现原理
4、分布式系统的一致性
5、http请求到Tomcat的整体流程
6、怎么保证分布式系统的稳定性
7、MVCC原理，怎么解决的幻读问题
8、个人优缺点