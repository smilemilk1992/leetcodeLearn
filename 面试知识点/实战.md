实战：
# redis-https://www.cnblogs.com/2020-zhy-jzoj/p/13164739.html
1、有没有遇到什么坑

    业务端一般认为redis出现问题，就是redis云有问题，人的“正常”思维：看别人错误容易，发现自己难，扯多了, 出现这个有很多原因：
       (1). 网络原因：比如是否存在跨机房、网络割接等等。
       (2). 慢查询，因为redis是单线程，如果有慢查询的话，会阻塞住之后的操作。 
       (3). value值过大？比如value几十兆，当然这种情况比较少，其实也可以看做是慢查询的一种
       (4). aof重写/rdb fork发生？瞬间会堵一下Redis服务器。
2、redis主从同步过程

    1.从服务发送一个sync同步命令给主服务要求全量同步。
    2.主服务接收到从服务的sync同步命令时，会fork一个子进程后台执行bgsave命令（非阻塞）快照保存，生成RDB文件，并将RDB文件发送给从服务。
    3.从服务再将接收到的RDB文件载入自己的redis内存。
    4.待从服务将RDB载入完成后，主服务再将缓冲区所有写命令发送给从服务。
    5.从服务在将主服务所有的写命令载入内存从而实现数据的完整同步。
    6.从服务下次在需要同步数据时只需要发送自己的offset位置（相当于MySQL binlog的位置）即可，只同步新增加的数据，再不需要全量同步。
    主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。

3、redis哨兵机制-https://www.jianshu.com/p/3677afe376ee

    哨兵(Sentinel)主要是为了解决在主从复制架构中出现宕机的情况,是建立在主从模式的基础上面的
    Redis-Sentinel是Redis官方推荐的高可用（HA）方案，当用Reids 做master-slave高可用方案时，假如master宕机了，redis本身（包括它的很多客服端）都没有实现自动的主备切换，而Redis-Sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能自动切换。



4、redis原理，跳表的时间复杂度

    Redis 是一款基于 ANSI C 语言编写的，BSD 许可的，日志型 key-value 存储组件，它的所有数据结构都存在内存中，可以用作缓存、数据库和消息中间件。
    redis是nosql(也是个巨大的map) 单线程，但是可处理1秒10w的并发（数据都在内存中）
    跳表其实是多条链表组成的链表结构，其特点在于查询时能够跳跃式查询。其复杂度取决于链表的跳跃区间的离散程度。


5、redis集群模式

    * 主从模式（主从模式的弊端就是不具备高可用性，当master挂掉以后，Redis将不能再对外提供写入操作）
        * 主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库
        * 从数据库一般都是只读的，并且接收主数据库同步过来的数据
        * 一个master可以拥有多个slave，但是一个slave只能对应一个master
        * slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来
        * master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务
        * master挂了以后，不会在slave节点中重新选一个master
        * 可以实现读写分离，数据备份。但是并不是「高可用」的
    
    * Sentinel模式
        * sentinel模式是建立在主从模式的基础上，如果只有一个Redis节点，sentinel就没有任何意义
        * 当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master
        * 当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据
        * sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群
        * 多sentinel配置的时候，sentinel之间也会自动监控
        * 当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中，不需要担心
        * 一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis
        * sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也挂了
        * Redis哨兵模式实现了高可用，读写分离，但是其主节点仍然只有一个，即写入操作都是在主节点中，这也成为了性能的瓶颈。
    * 集群模式
        * Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽， 集群的每个节点负责一部分 hash 槽。
        * 集群至少需要3主3从
        * 不仅提供了高可用的手段，同时数据是分片保存在各个节点中的，可以支持高并发的写入与读取。当然实现也是其中最复杂的。
        


6、redis雪崩和穿透怎么解决-https://zhuanlan.zhihu.com/p/58331707  https://www.cnblogs.com/liluxiang/p/10320491.html

    血崩：
    1、redis集群大面积故障
    2、缓存失效，但依然大量请求访问缓存服务redis
    3、redis大量失效后，大量请求转向到mysql数据库
    4、mysql的调用量暴增，很快就扛不住了，甚至直接宕机
    5、由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。
    
    如何解决：
    1、缓存高可用
    2、缓存降级
    3、Redis备份和快速预热
    4、提前演练
    
    穿透：
    缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。
    
    解决：
    如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。

    可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。
    
7、热点缓存问题-https://www.cnblogs.com/xuwc/p/14013060.html

    热key问题，指的就是缓存集群中的某个key在瞬间被数万甚至十万的并发请求打爆。大value问题，指的是某个key对应的value可能有gb级别的大小，导致查询value的时候会引发网络相关的故障问题。这里说一下热key问题。
    所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。
    那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。

    发现热key:
    1、凭借业务经验，进行预估哪些是热key
    2、在客户端进行收集
    3、在Proxy层做收集
    4、用redis自带命令
    
    如何解决：
    1、利用二级缓存
    比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。
    针对这种热key请求，会直接从jvm中取，而不会走到redis层。
    假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。
    现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。
    2、备份热key
    这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。
    3、监控热key
    4、通知系统做处理

# hashmap
1、HashMap内部怎么实现的
2、Hashmap扩容做了什么操作，为什么要扩容成两倍
3、HashMap的put操作过程
4、hashmap线程不安全的体现

#多线程
1、线程池拒绝策略
2、volatile的原理
3、	线程安全的场景和如何保证

#spring
1、spring循环依赖为什么用三级缓存
2、spring的bean是怎么管理的
3、applicationContext和springFactory的区别

#锁
1、偏向锁、轻量级锁、自旋锁、重量级锁的转化
2、读写锁的实现原理
3、Aqs原理

#mysql数据库
1、数据库索引为什么用B+树
2、分库分表场景
3、慢查询场景

# 消息队列
1、RocketMq的事务消息是怎么实现的
2、kafka与mq对比
3、RabbitMq怎么保证消息的可靠性
4、Kafka为什么可以保证extraclyOnece
5、Kafka怎么保证的高并发高可用

# JVM调优
1、CMS和G1回收算法的过程
2、Outofmemory的场景
3、FullGC和OutOfMemory有什么区别，怎么排查
4、Jvm调优的工具和命令
5、服务响应慢怎么排查

# 其他
1、	以前工作中难度最高和提升最大的项目
2、	复合索引的数据结构
3、可重复读的实现原理
4、分布式系统的一致性
5、http请求到Tomcat的整体流程
6、怎么保证分布式系统的稳定性
7、MVCC原理，怎么解决的幻读问题
8、个人优缺点