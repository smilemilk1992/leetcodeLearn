# volatile 是什么
volatile是java虚拟机提供的一种轻量级同步机制。
#volatile的作用
1、可以保证被volatile修饰的变量的读写具有原子性，不保证复合操作（i++操作等）的原子性；
2、禁止指令重排序；
3、被volatile修饰的的变量修改后，可以马上被其它线程感知到，保证可见性；
#volatile变量的特性
1、保证可见性，不保证原子性
    当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；
    这个写会操作会导致其他线程中的volatile变量缓存无效。
    读的话直接读主内存数据 
2、禁止指令重排
    重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：
    （1）重排序操作不会对存在数据依赖关系的操作进行重排序。
        比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。
    （2）重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变
        比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发生重排序，
        但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。
        重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，
    使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，
    会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：
        a.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
        b.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
    即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。
#volatile不适用的场景
1、volatile不适用复合操作，比如i++
2、解决方法：
    synchronized
    Lock
    采用java并发包中的原子操作类,比如AtomicInteger，原子操作类是通过CAS循环的方式来保证其原子性的
#volatile原理
volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。
观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
    （1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
    （2）它会强制将对缓存的修改操作立即写入主存；
    （3）如果是写操作，它会导致其他CPU中对应的缓存行无效。
#单例模式的双重锁为什么要加volatile
 需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字,会发生指令重排序，造成线程不安全问题
#并发编程3个基本概念
1、原子性：
    即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
    java中的原子性操作包括：
        （1）基本类型的读取和赋值操作，且赋值必须是值赋给变量，变量之间的相互赋值不是原子性操作。
        （2）所有引用reference的赋值操作-比如AtomicReference
        （3）java.concurrent.Atomic.* 包中所有类的一切操作（Atomic类是使用CAS+volatile来实现原子性与可见性的。）
2、可见性：
    指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
    在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，
    当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，
    其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。
    synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

3、有序性：
    即程序执行的顺序按照代码的先后顺序执行。
    Java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。
    前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。

    在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。
    Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，
    synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
#锁的互斥和可见性
锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。
1、互斥即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用该共享数据。
2、可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。
#java的内存模型JMM
JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：
    共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），
    本地内存保存了被该线程使用到的主内存的副本拷贝，
    线程对变量的所有操作都必须在工作内存中进行，
    而不能直接读写主内存中的变量。
 需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存
 
 #CAS+volatile=同步代码块
 总述同步代码块的实现原理：

使用 volatile 关键字修饰一个int类型的同步标志位state，初始值为0；
加锁/释放锁时使用CAS操作对同步标志位state进行更新；
加锁成功，同步标志位值为 1，加锁状态；
释放锁成功，同步标志位值为0，初始状态；
#Lock锁 与 synchronized锁 区别
1、Lock接口实现的类锁是核心类库中的代码 ，是 Java编写的；synchronized 是关键字，属于 JVM，也就是Java原生的，使用其他语言实现。
2、Lock实现类锁有更多方法，比如可以选择是公平锁还是非公平锁；一段时间获取不到资源可以退出等待队列；以及共享锁排它锁；而后者功能就比较单一了。
3、synchronized 可以修饰静态方法、实例方法、代码块；Lock 实现的锁只能修饰代码块
4、synchronized不需要释放锁，Lock锁需要手动释放。
相同点：
    都是可重入锁
    效率差不多（ jdk1.6优化以后）

#大话Synchronized
Synchronized虽然确保了线程的安全，但是在性能上却不是最优的，Synchronized关键字会让没有得到锁资源的线程进入BLOCKED状态
而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。
尽管Java1.6为Synchronized做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。

所谓原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如AtomicBoolean，AtomicInteger，AtomicLong。
它们分别用于Boolean，Integer，Long类型的原子性操作。
而Atomic操作的底层实现正是利用的CAS机制，好的，我们切入到这个博客的正点。
#大话CAS
1、比较并交换
2、CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。
3、更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。
4、从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。
5、CAS的缺点：
    1、CPU开销较大
        在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。
    2、不能保证代码块的原子性
        CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。
    3、ABA问题
        因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，
        那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，
        每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
#concurrent包的实现
由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：
    A线程写volatile变量，随后B线程读这个volatile变量。
    A线程写volatile变量，随后B线程用CAS更新这个volatile变量。
    A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。
    A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。
concurrent包的源码实现，会发现一个通用化的实现模式：
    首先，声明共享变量为volatile；
    然后，使用CAS的原子条件更新来实现线程之间的同步；
    同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。