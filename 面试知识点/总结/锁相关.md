# volatile 是什么
volatile是java虚拟机提供的一种轻量级同步机制。
#volatile的作用
1、可以保证被volatile修饰的变量的读写具有原子性，不保证复合操作（i++操作等）的原子性；
2、禁止指令重排序；
3、被volatile修饰的的变量修改后，可以马上被其它线程感知到，保证可见性；
#volatile变量的特性
1、保证可见性，不保证原子性
    当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；
    这个写会操作会导致其他线程中的volatile变量缓存无效。
    读的话直接读主内存数据 
2、禁止指令重排
    重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：
    （1）重排序操作不会对存在数据依赖关系的操作进行重排序。
        比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。
    （2）重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变
        比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发生重排序，
        但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。
        重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，
    使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，
    会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：
        a.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
        b.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
    即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。
#volatile不适用的场景
1、volatile不适用复合操作，比如i++
2、解决方法：
    synchronized
    Lock
    采用java并发包中的原子操作类,比如AtomicInteger，原子操作类是通过CAS循环的方式来保证其原子性的
#volatile原理
volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。
观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
    （1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
    （2）它会强制将对缓存的修改操作立即写入主存；
    （3）如果是写操作，它会导致其他CPU中对应的缓存行无效。
#单例模式的双重锁为什么要加volatile
 需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字,会发生指令重排序，造成线程不安全问题
#并发编程3个基本概念
1、原子性：
    即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
    java中的原子性操作包括：
        （1）基本类型的读取和赋值操作，且赋值必须是值赋给变量，变量之间的相互赋值不是原子性操作。
        （2）所有引用reference的赋值操作-比如AtomicReference
        （3）java.concurrent.Atomic.* 包中所有类的一切操作（Atomic类是使用CAS+volatile来实现原子性与可见性的。）
2、可见性：
    指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
    在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，
    当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，
    其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。
    synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

3、有序性：
    即程序执行的顺序按照代码的先后顺序执行。
    Java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。
    前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。

    在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。
    Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，
    synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
#锁的互斥和可见性
锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。
1、互斥即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用该共享数据。
2、可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。
#java的内存模型JMM
JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：
    共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），
    本地内存保存了被该线程使用到的主内存的副本拷贝，
    线程对变量的所有操作都必须在工作内存中进行，
    而不能直接读写主内存中的变量。
 需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存
 
 #CAS+volatile=同步代码块
 总述同步代码块的实现原理：

使用 volatile 关键字修饰一个int类型的同步标志位state，初始值为0；
加锁/释放锁时使用CAS操作对同步标志位state进行更新；
加锁成功，同步标志位值为 1，加锁状态；
释放锁成功，同步标志位值为0，初始状态；
#Lock锁 与 synchronized锁 区别
1、Lock接口实现的类锁是核心类库中的代码 ，是 Java编写的；synchronized 是关键字，属于 JVM，也就是Java原生的，使用其他语言实现。
2、Lock实现类锁有更多方法，比如可以选择是公平锁还是非公平锁；一段时间获取不到资源可以退出等待队列；以及共享锁排它锁；而后者功能就比较单一了。
3、synchronized 可以修饰静态方法、实例方法、代码块；Lock 实现的锁只能修饰代码块
4、synchronized不需要释放锁，Lock锁需要手动释放。
相同点：
    都是可重入锁
    效率差不多（ jdk1.6优化以后）

#大话Synchronized
Synchronized虽然确保了线程的安全，但是在性能上却不是最优的，Synchronized关键字会让没有得到锁资源的线程进入阻塞状态
而后在争夺到锁资源后恢复为唤醒状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。
尽管Java1.6为Synchronized做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。

所谓原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如AtomicBoolean，AtomicInteger，AtomicLong。
它们分别用于Boolean，Integer，Long类型的原子性操作。
而Atomic操作的底层实现正是利用的CAS机制，好的，我们切入到这个博客的正点。
#大话CAS
1、比较并交换
2、CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。
3、更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。
4、从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。
5、CAS的缺点：
    1、CPU开销较大
        在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。
    2、不能保证代码块的原子性
        CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。
    3、ABA问题
        因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，
        那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，
        每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
#concurrent包的实现
由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：
    A线程写volatile变量，随后B线程读这个volatile变量。
    A线程写volatile变量，随后B线程用CAS更新这个volatile变量。
    A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。
    A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。
concurrent包的源码实现，会发现一个通用化的实现模式：
    首先，声明共享变量为volatile；
    然后，使用CAS的原子条件更新来实现线程之间的同步；
    同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。

#谈谈AQS
1、AQS，即 AbstractQueuedSynchronizer 抽象队列同步器，是一个用来构建锁和同步器的类，JUC Lock包下的锁（常用的有ReentrantLock、ReadWriteLock），
以及其他的像Semaphore、CountDownLatch，甚至是早期的FutureTask等，都是基于AQS来构建的；

2、AQS在内部定义了一个变量：volatile int state，用于表示同步状态：当线程调用lock方法时，如果state=0，说明没有任何线程占有共享资源的锁，
可以获得锁并将state=1；如果state=1，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。

3、AQS内部是通过Node实体类来表示一个双向链表结构的同步队列，完成线程获取锁的排队工作，当有线程获取锁失败后，就被添加到队列末尾。

4、AQS通过内部类ConditionObject构建等待队列（可有多个），当Condition调用wait()方法后，线程将会加入等待队列中，
而当Condition调用signal()方法后，线程将从等待队列转移动同步队列中竞争锁。

5、AQS和Condition各自维护了不同的队列，在使用Lock和Condition的时候，其实就是两个队列的互相移动。

#用户态和内核态
当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态

所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等.，
而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作
（比如java的I/O操作底层都是通过native方法来调用操作系统）。
比如前面提到的Java程序阻塞和唤醒一个线程时就需要切换到内核态。

用户态切换到内核态的三种方式：
    1、系统调用
        这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使 用操作系统提供的服务程序完成工作，比如print()实际上就是执行了一个输出的系统调用。
    2、异常
        当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
    3、外围设备的中断
        当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会 暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到 内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

#锁相关升级-https://www.cnblogs.com/caibixiang123/p/9497191.html
锁一共4种状态，级别从低到高依次是：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态，
这个几个状态会随着竞争状态进行升级。锁可以升级但不能降级，意味者偏向锁升级成轻量级锁不能降级成偏向锁。
这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

所谓的锁升级降级就是讲的JVM针对不同的锁竞争会自动切换到适合的锁实现。
当没有竞争时，默认使用偏向锁，JVM会利用CAS操作，在对象头上的Mark Word部分设置线程ID,
表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁，在很多应用场景，大部分对象最多会被一个线程锁定，
使用偏向锁可以降低无竞争开销。如果有另外线程试图锁定某个已经被偏向过的对象，JVM就需要撤销偏向锁，
并切换到轻量级锁，轻量级锁依赖CAS操作Mark Word 来试图获取锁，如果重试成功，就是用轻量级锁，否则，升级为重量级锁。
#为什么线程切换会导致用户态与内核台的切换
因为线程的调度是在内核态运行的，而线程中的代码是在用户态运行。
#锁优化
jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁的操作的开销。
锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。
1、自旋锁
    线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。
    同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。
    所以引入自旋锁。 所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。
    自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，
    但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，
    它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，
    如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。
2、适应自旋锁
    JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
    线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。
    反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。
3、锁消除
     为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。
4、偏向锁
    Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，
    不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。如果在运行过程中，遇到了其他线程抢占锁，
    则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。
    偏向锁获取过程：
        1、访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。
        2、如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。
        3、如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。
        4、如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）
        5、执行同步代码。
    偏向锁的适用场景：始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，
    升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作；在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，
    安全点会导致stop the word，导致性能下降，这种情况下应当禁用。
    优点：加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距
    缺点：如果线程间存在锁竞争，会带来额外的锁撤销的消耗
    适应场景：适用于只有一个线程访问同步块场景
5、轻量级锁
    如果成功使用CAS将对象头重的Mark Word替换为指向锁记录的指针，则获得锁，失败则当前线程尝试使用自旋(循环等待)来获取锁。
    当有另一个线程与该线程同时竞争时，锁会升级为重量级锁。为了防止继续自旋，一旦升级，将无法降级。
    优点：竞争的线程不会阻塞，提高了程序的响应速度
    缺点：如果始终得不到索竞争的线程，使用自旋会消耗CPU
    适应场景：追求响应速度，同步块执行速度非常快
6、重量级锁
    其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程，进行竞争。
    轻量级锁依赖CAS操作Mark Word 来试图获取锁，如果重试成功，就是用轻量级锁，否则，升级为重量级锁。
    优点：线程竞争不使用自旋，不会消耗CPU
    缺点：线程阻塞，响应时间缓慢
    适应场景：追求吞吐量，同步块执行速度较慢
    


