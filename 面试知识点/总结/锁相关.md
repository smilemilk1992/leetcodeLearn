# volatile 是什么
volatile是java虚拟机提供的一种轻量级同步机制。
#volatile的作用
1、可以保证被volatile修饰的变量的读写具有原子性，不保证复合操作（i++操作等）的原子性；
2、禁止指令重排序；
3、被volatile修饰的的变量修改后，可以马上被其它线程感知到，保证可见性；
#volatile变量的特性
1、保证可见性，不保证原子性
    当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；
    这个写会操作会导致其他线程中的volatile变量缓存无效。
    读的话直接读主内存数据 
2、禁止指令重排
    重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：
    （1）重排序操作不会对存在数据依赖关系的操作进行重排序。
        比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。
    （2）重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变
        比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发生重排序，
        但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。
        重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，
    使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，
    会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：
        a.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
        b.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
    即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。
#volatile不适用的场景
1、volatile不适用复合操作，比如i++
2、解决方法：
    synchronized
    Lock
    采用java并发包中的原子操作类,比如AtomicInteger，原子操作类是通过CAS循环的方式来保证其原子性的
#volatile原理
volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。
观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
    （1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
    （2）它会强制将对缓存的修改操作立即写入主存；
    （3）如果是写操作，它会导致其他CPU中对应的缓存行无效。
#单例模式的双重锁为什么要加volatile
 需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字,会发生指令重排序，造成线程不安全问题
#并发编程3个基本概念
1、原子性：
    即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
    java中的原子性操作包括：
        （1）基本类型的读取和赋值操作，且赋值必须是值赋给变量，变量之间的相互赋值不是原子性操作。
        （2）所有引用reference的赋值操作-比如AtomicReference
        （3）java.concurrent.Atomic.* 包中所有类的一切操作（Atomic类是使用CAS+volatile来实现原子性与可见性的。）
2、可见性：
    指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
    在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，
    当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，
    其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。
    synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

3、有序性：
    即程序执行的顺序按照代码的先后顺序执行。
    Java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。
    前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。

    在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。
    Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，
    synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
#锁的互斥和可见性
锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。
1、互斥即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用该共享数据。
2、可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。
#java的内存模型JMM
JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：
    共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），
    本地内存保存了被该线程使用到的主内存的副本拷贝，
    线程对变量的所有操作都必须在工作内存中进行，
    而不能直接读写主内存中的变量。
 需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存
 
 #CAS+volatile=同步代码块
 总述同步代码块的实现原理：

使用 volatile 关键字修饰一个int类型的同步标志位state，初始值为0；
加锁/释放锁时使用CAS操作对同步标志位state进行更新；
加锁成功，同步标志位值为 1，加锁状态；
释放锁成功，同步标志位值为0，初始状态；
#Lock锁 与 synchronized锁 区别
1、Lock接口实现的类锁是核心类库中的代码 ，是 Java编写的；synchronized 是关键字，属于 JVM，也就是Java原生的，使用其他语言实现。
2、Lock实现类锁有更多方法，比如可以选择是公平锁还是非公平锁；一段时间获取不到资源可以退出等待队列；以及共享锁排它锁；而后者功能就比较单一了。
3、synchronized 可以修饰静态方法、实例方法、代码块；Lock 实现的锁只能修饰代码块
4、synchronized不需要释放锁，Lock锁需要手动释放。
相同点：
    都是可重入锁
    效率差不多（ jdk1.6优化以后）

#大话Synchronized
Synchronized虽然确保了线程的安全，但是在性能上却不是最优的，Synchronized关键字会让没有得到锁资源的线程进入阻塞状态
而后在争夺到锁资源后恢复为唤醒状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。
尽管Java1.6为Synchronized做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。

所谓原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如AtomicBoolean，AtomicInteger，AtomicLong。
它们分别用于Boolean，Integer，Long类型的原子性操作。
而Atomic操作的底层实现正是利用的CAS机制，好的，我们切入到这个博客的正点。
#大话CAS
1、比较并交换
2、CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。
3、更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。
4、从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。
5、CAS的缺点：
    1、CPU开销较大
        在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。
    2、不能保证代码块的原子性
        CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。
    3、ABA问题
        因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，
        那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，
        每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
#concurrent包的实现
由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：
    A线程写volatile变量，随后B线程读这个volatile变量。
    A线程写volatile变量，随后B线程用CAS更新这个volatile变量。
    A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。
    A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。
concurrent包的源码实现，会发现一个通用化的实现模式：
    首先，声明共享变量为volatile；
    然后，使用CAS的原子条件更新来实现线程之间的同步；
    同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。

#谈谈AQS
1、AQS，即 AbstractQueuedSynchronizer 抽象队列同步器，是一个用来构建锁和同步器的类，JUC Lock包下的锁（常用的有ReentrantLock、ReadWriteLock），
以及其他的像Semaphore、CountDownLatch，甚至是早期的FutureTask等，都是基于AQS来构建的；

2、AQS在内部定义了一个变量：volatileint state，用于表示同步状态：当线程调用lock方法时，如果state=0，说明没有任何线程占有共享资源的锁，
可以获得锁并将state=1；如果state=1，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。

3、AQS内部是通过Node实体类来表示一个双向链表结构的同步队列，完成线程获取锁的排队工作，当有线程获取锁失败后，就被添加到队列末尾。

4、AQS通过内部类ConditionObject构建等待队列（可有多个），当Condition调用wait()方法后，线程将会加入等待队列中，
而当Condition调用signal()方法后，线程将从等待队列转移动同步队列中竞争锁。

5、AQS和Condition各自维护了不同的队列，在使用Lock和Condition的时候，其实就是两个队列的互相移动。

#用户态和内核态
当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态

所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等.，
而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作
（比如java的I/O操作底层都是通过native方法来调用操作系统）。
比如前面提到的Java程序阻塞和唤醒一个线程时就需要切换到内核态。

用户态切换到内核态的三种方式：
    1、系统调用
        这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使 用操作系统提供的服务程序完成工作，比如print()实际上就是执行了一个输出的系统调用。
    2、异常
        当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
    3、外围设备的中断
        当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会 暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到 内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

#锁相关升级-https://www.cnblogs.com/caibixiang123/p/9497191.html
锁一共4种状态，级别从低到高依次是：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态，
这个几个状态会随着竞争状态进行升级。锁可以升级但不能降级，意味者偏向锁升级成轻量级锁不能降级成偏向锁。
这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

所谓的锁升级降级就是讲的JVM针对不同的锁竞争会自动切换到适合的锁实现。
当没有竞争时，默认使用偏向锁，JVM会利用CAS操作，在对象头上的Mark Word部分设置线程ID,
表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁，在很多应用场景，大部分对象最多会被一个线程锁定，
使用偏斜锁可以降低无竞争开销。如果有另外线程试图锁定某个已经被偏向过的对象，JVM就需要撤销偏向锁，
并切换到轻量级锁，轻量级锁依赖CAS操作Mark Word 来试图获取锁，如果重试成功，就是用轻量级锁，否则，升级为重量级锁。
#为什么线程切换会导致用户态与内核台的切换
因为线程的调度是在内核态运行的，而线程中的代码是在用户态运行。