#数据库索引为什么用B+树
    数据库使用B+树肯定是为了提升查找效率。
    b+树只有叶节点存放数据，其余节点用来存索引，而b树是每个索引节点都会有Data域（即每个索引都存储索引+数据）
    答1：B树在提高了IO性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决这个问题，B+树应用而生。
        B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。
    答2：1、B+树的磁盘读写代价更低 B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
         2、B+树的查询效率更加稳定 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
         3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。
#什么是索引
索引是对数据库表中的一列或多列值进行排序的一种结构，使用索引可以快速访问数据库表中的特定信息。
#索引的作用？
索引相当于图书上的目录，可以根据目录上的页码快速找到所需的内容，提高性能（查询速度）
#索引优点？
通过创建唯一性索引，可以保证数据库表中的每一行数据的唯一性。
可以加快数据的检索速度
可以加速表与表之间的连接
在使用分组和排序进行检索的时候，可以减少查询中分组和排序的时间
#建立索引缺点
创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
索引需要占用物理空间，数据量越大，占用空间越大
会降低表的增删改的效率，因为每次增删改索引，都需要进行动态维护
#什么时候需要创建索引
主键自动建立唯一索引
频繁作为查询条件的字段应该创建索引
查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找）
查询中统计或者分组的字段；
#什么时候不需要创建索引
1、频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件
2、where条件里用不到的字段，不创建索引；
3、表记录太少，不需要创建索引；
4、经常增删改的表；
5、数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，
因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。
#索引的分类
普通索引：最基本的索引，它没有任何限制
唯一索引：索引列的值必须唯一，且不能为空，如果是组合索引，则列值的组合必须唯一。
主键索引：特殊的索引，唯一的标识一条记录，不能为空，一般用primary key来约束。
联合索引：在多个字段上建立索引，能够加速查询到速度
# mysql何时使用索引？
1、对一个键码使用>, >=, =, <, <=, IF NULL和BETWEEN
2、当使用不以通配符开始的LIKE
3、在进行联结时从另一个表中提取行时
4、找出指定索引的MAX()或MIN()值
5、一个键码的前缀使用ORDER BY或GROUP BY

#mysql索引
1、B+ Tree索引
是大多数 MySQL 存储引擎的默认索引类型。
因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。
因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。
可以指定多个列作为索引列，多个索引列共同组成键。
适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

#MVCC(多版本并发控制 解决泛读)
多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。
加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。
读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。
在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。
脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当
然一个事务可以读取自身未提交的快照，这不算是脏读。

简要回答：
1、每行数据都存在一个版本，每次数据更新时都更新该版本。
2、修改时Copy出当前版本随意修改，各个事务之间无干扰。
3、保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）