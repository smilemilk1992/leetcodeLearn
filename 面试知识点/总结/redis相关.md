#redis能否将数据持久化，如何实现
Redis持久化有两种方式，分别是RDB（又称快照）与AOF。对于两种方式各有优缺点，具体如下：
RDB（数据快照）：通过bgsave命令触发，异步全量一次同步内存中所有序列化的二进制数据，同步慢，数据较小。单独使用RDB持久化，存在数据丢失风险（半持久化）
AOF（日志追加）：增量同步操作指令，同步较快，数据量随时间增加而增多，需定期进行AOF文件重写，以便减小日志文件。（全持久化）
Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。
在日常操作中，一般都是从AOF日志中来恢复数据，因为RDB会丢失大量数据。但是AOF恢复数据又会花费较长时间。
于是从Redis4.0开始，Redis开始支持混合持久化。即将RDB与AOF结合使用，RDB负责定时全量持久化数据，AOF负责记录最后一次RDB后的增量日志。使得Redis的数据恢复在恢复效率与数据完整性之间取得一个完美的平衡点。

#redis五大基本类型常用场景-https://www.cnblogs.com/CryFace/p/13762241.html
https://www.jianshu.com/p/c7c352cb14fe
String:三种编码形式来组成的，分别是int，raw，embstr。这里int主要是用来存放整形值的字符串，embstr用来存放字符串的短字符串（大小不超过44个字节），raw存放字符的长字符串（大小不超过44个字节）。
    缓存、限流、计数器、分布式锁、分布式Session
Hash:哈希类型的底层编码可以是ziplist也可以是我们的hashtable
    存储用户信息、购物车等管理
List:使用的是压缩列表ziplist和普通的双向链表linkedlist组成。元素少的时候会用ziplist，元素多的时候会用linkedlist。
    微博关注人时间轴列表、消息队列，最新列表，排行榜
Set:底层编码包括hashtable和inset。
    赞、踩、标签、好友关系、交集并集（共同关注了）
    随机数。这里可以使用spop/srandmember命令来获取随机数，可以做一个抽奖功能等。
    社交需求。类似sadd/sinter命令可以添加你有多少个朋友的共同好友等操作，类似可能认识的人。
    交集，并集，差集。这里如交集可以用来如一个用户对娱乐 、体育比较感兴趣，另一个可能对新闻比较感兴趣，他们就有共同的标签，可以做互相推荐的功能，喜欢体育的人还喜欢娱乐。类似其他的功能都可以抽象一点去想象用法。
Zset:一个ziplist，一个是skiplist（跳表）。
    实时排行榜-比如我们要做一个一小时热搜，我们可以把当前的时间戳作为zset的key，把帖子ID作为member，点击数评论数作为score，当score发生变化时更新score。然后可以利用zrevrange或zrange来来查到对应数量的在时间内的记录。
    延时队列-zset会按照score进行排序，如果score代表想要执行时间的时间戳。在某个时间将它插入zset集合中，它便会按照时间戳大小进行排序，也就是对执行时间前后进行排序。
    限流-滑动窗口是限流常见的一种策略。如果我们把一个用户的 ID 作为 key 来定义一个 zset ，member 或者 score 都为访问时的时间戳。
    我们只需统计某个 key 下在指定时间戳区间内的个数，就能得到这个用户滑动窗口内访问频次，与最大通过次数比较，来决定是否允许通过。

#redis跳表
跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。
Redis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的元素数量比较多,又或者有序集合中元素的成员是比较长的字符串时, 
Redis就会使用跳跃表来作为有序集合健的底层实现。

#为啥 redis 单线程模型也能效率这么高？
纯内存操作

核心是基于非阻塞的 IO 多路复用机制

单线程反而避免了多线程的频繁上下文切换问题

