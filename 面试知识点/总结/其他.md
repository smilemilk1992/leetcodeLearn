#java设计模式-https://zhuanlan.zhihu.com/p/93770973 https://zhuanlan.zhihu.com/p/61100871
1、创建型模式（5）
    工厂模式：普通工厂模式、多个工厂方法模式，静态工厂方法模式
        工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。
    抽象工厂模式
        工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。
    单例模式
        单例模式是设计模式中最常见也最简单的一种设计模式，保证了在程序中只有一个实例存在并且能全局的访问到。
        包括：饿汉模式、懒汉模式、静态代码块、静态内置类、枚举数据类型实现
    创造者模式
    原型模式
2、结构性模式（7）
    适配器模式：作为两个不兼容的接口之间的桥梁（类、对象、接口的适配器模式）
    装饰器模式：而装饰模式的目的是在不修改类的情况下给类增加新的功能。（类似继承）
    桥接模式
    外观模式
    代理模式：代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。
    组合模式
    享元模式
3、行为型模式（11）
    策略模式
    模板方法模式
    观察者模式
        对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
    迭代子模式
    责任链模式-牛掰
    命令模式
    备忘录模式
    状态模式
    访问者模式
    中介者模式
    解释器模式。


#设计模式的六大原则
1、开闭原则
    开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
2、里氏代换原则
    里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
3、依赖倒转原则
    这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
4、接口隔离原则
    使用多个隔离的接口，比使用单个接口要好。降低依赖，降低耦合。
5、迪米特法则
    一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
6、合成复用原则
    尽量使用合成/聚合的方式，而不是使用继承。

#java中抽象类与接口之间有什么区别？
1、一个类可以实现多个接口 ，但却只能继承最多一个抽象类。
2、抽象类可以包含具体的方法 ， 接口的所有方法都是抽象的。
3、抽象类可以声明和使用字段 ，接口则不能，但接口可以创建静态的final常量。
4、接口的方法都是public的，抽象类的方法可以是public，protected，private或者默认的package；
5、抽象类可以定义构造函数，接口却不能。

#java 重写和重载-https://www.runoob.com/java/java-override-overload.html
重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。
重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，
但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。
重写是建立在继承关系上

所谓方法重载是指在一个类中，多个方法的方法名相同，但是参数列表不同。参数列表不同指的是参数个数、参数类型或者参数的顺序不同。
返回类型呢？可以相同也可以不同。
被重载的方法必须改变参数列表；
被重载的方法可以改变返回类型；
被重载的方法可以改变访问修饰符；
被重载的方法可以声明新的或更广的检查异常；
方法能够在同一个类中或者在一个子类中被重载。


重写与重载之间的区别

方法重载：
1、同一个类中
2、方法名相同，参数列表不同（参数顺序、个数、类型）
3、方法返回值、访问修饰符任意
4、与方法的参数名无关

方法重写：
1、有继承关系的子类中
2、方法名相同，参数列表相同（参数顺序、个数、类型），方法返回值相同
3、访问修饰符，访问范围需要大于等于父类的访问范围
4、与方法的参数名无关
    


抽象类总结规定
1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。

2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

#NIO & 多路复用-https://www.jianshu.com/p/d47835316016
NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。
传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，
数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。
因此，单个线程可以监听多个数据通道。
NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。
IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。
NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。


NIO采用内存映射文件的方式来处理输入输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样访问文件了。
NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同， NIO支持面向缓冲区(Buffer)的、基于通道(Channel)的IO操作。
NIO将以更加高效的方式进行文件的读写操作。

NIO：https://tech.meituan.com/2016/11/04/nio.html
1、缓冲区Buffer
2、通道Channel
3、选择器Selector

#NIO给我们带来了什么
事件驱动模型
避免多线程
单线程处理多任务
非阻塞I/O，I/O读写不再阻塞，而是返回0
基于block的传输，通常比基于流的传输更高效
更高级的IO函数，zero-copy
IO多路复用大大提高了Java网络应用的可伸缩性和实用性

# 对象和类的关系
对象：对象是人们要进行研究的任何事物，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。
类：具有相同特性（数据元素）和行为（功能）的对象的抽象就是类。
类的实力化的结果就是对象，而对对象的抽象就是类，类描述了一组有相同特性（属性）和相同行为的对象。

# happens-before
JMM 内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现各种happen-before规则。
happen-before原则是JMM中非常重要的原则，它是判断数据是否存在竞争、线程是否安全的主要依据，保证了多线程环境下的可见性。

A happens-before B,定义1要求A执行结果对B可见，并且A操作的执行顺序在B操作之前，但与此同时利用定义中的第二条，A,B操作彼此不存在数据依赖性，
两个操作的执行顺序对最终结果都不会产生影响，在不改变最终结果的前提下，允许A，B两个操作重排序，即happens-before关系并不代表了最终的执行顺序。

#io多路复用
当使用io多路复用时，有多个C端同时发送请求，这些IO操作会被selector(epoll，kqueue)给暂时挂起，入内存队列。
此时S端可以自己选择什么时候读取、处理这些io，也就是说S端可以同时hold住多个io。


#final 和static区别

#微服务注册中心ZooKeeper、Eureka、Consul 、Nacos对比-https://blog.csdn.net/fly910905/article/details/100023415

#标记清除算法
该算法是将垃圾的回收分为两个阶段，分别为标记和清除，首先是标记，如下图，会采用可达性分析算法，找出可用和不可用的对象，
将可用的对象的mark值设置为1，不可用的为0。然后就会进行第二个阶段，也就是清除阶段，这里会把mark为0的对象进行垃圾回收，
然后将剩余对象的mark设为0，等待下一次标记。
#标记压缩算法
标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，
在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。
#复制算法
复制算法就是将没存空间一分为二，存储时只使用其中的一块空间，当进行垃圾回收的时候，找出正在使用的对象，
并将这些对象复制到另一块内存空间中，然后将该内存清空，交换两个空间的角色，实现垃圾的回收。
#cms回收算法过程
cms-高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择。。标记清除，可以设置参数进行内存整理
    过程：
    初始标记：STW只标记GC Roots直接引用的对象
    并发标记：和用户线程并发执行可达性分析标记
    重新标记：STW修正并发标记中修改的部分
    并发清除：和用户线程并发执行清除工作。
    缺点：
    CPU资源敏感，因为并发标记会占用一定CPU资源，导致用户线程的资源变小。
    无法处理浮动垃圾，因为清理阶段是和用户线程并发的，所以在清除过程中还会产生垃圾。
    内存空间碎片。
#G1回收算法过程
G1回收器-整体是标记整理，局部是复制算法。
    G1管理整个GC堆，分成不同的Region，维护一个优先列表，记录每个Region的价值，价值是由之前这个区域GC所获空间大小和GC所需时间来决定的。
    初始标记：STW标记GC Roots直接引用的对象。
    并发标记：和用户线程并发执行可达性分析标记，这个过程中的引用变化会记录到Remebered Set Logs。
    最终标记：STW修正并发标记过程中改变的引用，合并Remebered Set Logs到Rememebered Set。
    筛选回收：对所有Region进行价值排序，根据用户决定的GC耗时来取价值高的Region进行回收工作。这个部分是STW，因为只对部分区域回收，不会太耗时，并且耗时时间也是用户自己决定的。
#强引用、软引用、弱引用、虚拟引用
强引用：
    当内存不足的时候，JVM开始垃圾回收，对于强引用的对象，就算出现了OOM也不会对该对象进行回收，
    强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就表明对象还“活着”，垃圾处理器不会碰这种对象
    把一个对象赋给一个引用变量，这个引用变量就是强引用，强引用是内存泄露的主要原因
    Object obj1=new Object()
    Object obj2=obj1
    obj1=null
    System.gc()
    System.out.println(obj2)
软引用：
    软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftRefernce类来实现，可以让对象豁免一些垃圾收集
    内存足够的前提下我不收
    内存不够的情况我吧你收了
    软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用就保留，不够用就回收
弱引用：
    WeakHashMap
    需要用java.lang.ref.WeakRefernce类来实现,它比软引用的生命周期更短
    对于弱引用对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存
虚拟引用：
    需要用java.lang.ref.PhantomRefernce类来实现
    顾名思义，就是形同虚设(get方法总是null)，与其他几种引用都不同，虚引用并不会决定对象的生命周期
    如果一个对象仅持有虚引用的时候，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，
    它不能单独使用也不能通过访问对象，虚引用必须和引用队列（RefernceQuene）联合使用

锁相关
# 公平 & 非公平
ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁和非公平锁，默认是非公平锁false,非公平锁的优点是吞吐量比公平锁大
对于Synchronized是非公平锁
公平锁：是指多个线程按照申请锁的顺序来获取锁
非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取到锁，在高并发的情况下，有可能造成优先级反转或者饥饿现象
 
# 可重入锁（又名递归锁）最大作用是避免死锁
指的是同一线程外层函数获得锁之后，内层递归函数仍然可以获取该锁的代码，
在同一个线程在外层获取锁的时候，在进入内层方法会自动获取锁

也就是说，线程可以进入任何一个它已经拥有的锁所同步这的代码块；

#自旋锁
是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样做的好处是减少线程上下文切换的消耗，
缺点是循环会消耗CPU

#独占锁
指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁

# 共享锁
对ReentrantReadWriteLock其读锁是共享锁， 写锁的独占锁。
读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的！