#java设计模式-https://zhuanlan.zhihu.com/p/93770973 https://zhuanlan.zhihu.com/p/61100871
1、创建型模式（5）
    工厂模式：普通工厂模式、多个工厂方法模式，静态工厂方法模式
        工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。
    抽象工厂模式
        工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。
    单例模式
        单例模式是设计模式中最常见也最简单的一种设计模式，保证了在程序中只有一个实例存在并且能全局的访问到。
        包括：饿汉模式、懒汉模式、静态代码块、静态内置类、枚举数据类型实现
    创造者模式
    原型模式
2、结构性模式（7）
    适配器模式：作为两个不兼容的接口之间的桥梁（类、对象、接口的适配器模式）
    装饰器模式：而装饰模式的目的是在不修改类的情况下给类增加新的功能。（类似继承）
    桥接模式
    外观模式
    代理模式：代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。
    组合模式
    享元模式
3、行为型模式（11）
    策略模式
    模板方法模式
    观察者模式
        对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
    迭代子模式
    责任链模式-牛掰
    命令模式
    备忘录模式
    状态模式
    访问者模式
    中介者模式
    解释器模式。


#设计模式的六大原则
1、开闭原则
    开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
2、里氏代换原则
    里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
3、依赖倒转原则
    这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
4、接口隔离原则
    使用多个隔离的接口，比使用单个接口要好。降低依赖，降低耦合。
5、迪米特法则
    一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
6、合成复用原则
    尽量使用合成/聚合的方式，而不是使用继承。

#java中抽象类与接口之间有什么区别？
1、一个类可以实现多个接口 ，但却只能继承最多一个抽象类。
2、抽象类可以包含具体的方法 ， 接口的所有方法都是抽象的。
3、抽象类可以声明和使用字段 ，接口则不能，但接口可以创建静态的final常量。
4、接口的方法都是public的，抽象类的方法可以是public，protected，private或者默认的package；
5、抽象类可以定义构造函数，接口却不能。

#java 重写和重载-https://www.runoob.com/java/java-override-overload.html
重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。
重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，
但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。
重写是建立在继承关系上

所谓方法重载是指在一个类中，多个方法的方法名相同，但是参数列表不同。参数列表不同指的是参数个数、参数类型或者参数的顺序不同。
返回类型呢？可以相同也可以不同。
被重载的方法必须改变参数列表；
被重载的方法可以改变返回类型；
被重载的方法可以改变访问修饰符；
被重载的方法可以声明新的或更广的检查异常；
方法能够在同一个类中或者在一个子类中被重载。


重写与重载之间的区别

方法重载：
1、同一个类中
2、方法名相同，参数列表不同（参数顺序、个数、类型）
3、方法返回值、访问修饰符任意
4、与方法的参数名无关

方法重写：
1、有继承关系的子类中
2、方法名相同，参数列表相同（参数顺序、个数、类型），方法返回值相同
3、访问修饰符，访问范围需要大于等于父类的访问范围
4、与方法的参数名无关
    


抽象类总结规定
1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。

2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

#NIO & 多路复用-https://www.jianshu.com/p/d47835316016
NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。
传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，
数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。
因此，单个线程可以监听多个数据通道。
NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。
IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。
NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。


NIO采用内存映射文件的方式来处理输入输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样访问文件了。
NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同， NIO支持面向缓冲区(Buffer)的、基于通道(Channel)的IO操作。
NIO将以更加高效的方式进行文件的读写操作。

NIO：https://tech.meituan.com/2016/11/04/nio.html
1、缓冲区Buffer
2、通道Channel
3、选择器Selector

#NIO给我们带来了什么
事件驱动模型
避免多线程
单线程处理多任务
非阻塞I/O，I/O读写不再阻塞，而是返回0
基于block的传输，通常比基于流的传输更高效
更高级的IO函数，zero-copy
IO多路复用大大提高了Java网络应用的可伸缩性和实用性

# 对象和类的关系
对象：对象是人们要进行研究的任何事物，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。
类：具有相同特性（数据元素）和行为（功能）的对象的抽象就是类。
类的实力化的结果就是对象，而对对象的抽象就是类，类描述了一组有相同特性（属性）和相同行为的对象。

# happens-before
JMM 内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现各种happen-before规则。
happen-before原则是JMM中非常重要的原则，它是判断数据是否存在竞争、线程是否安全的主要依据，保证了多线程环境下的可见性。

A happens-before B,定义1要求A执行结果对B可见，并且A操作的执行顺序在B操作之前，但与此同时利用定义中的第二条，A,B操作彼此不存在数据依赖性，
两个操作的执行顺序对最终结果都不会产生影响，在不改变最终结果的前提下，允许A，B两个操作重排序，即happens-before关系并不代表了最终的执行顺序。

#io多路复用
当使用io多路复用时，有多个C端同时发送请求，这些IO操作会被selector(epoll，kqueue)给暂时挂起，入内存队列。
此时S端可以自己选择什么时候读取、处理这些io，也就是说S端可以同时hold住多个io。


#final 和static区别

#微服务注册中心ZooKeeper、Eureka、Consul 、Nacos对比-https://blog.csdn.net/fly910905/article/details/100023415