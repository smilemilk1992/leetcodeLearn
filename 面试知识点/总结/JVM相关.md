# JVM有哪些内存区域？(JVM的内存布局是什么？)
JVM包含堆、元空间、Java虚拟机栈、本地方法栈、程序计数器等内存区域。
其中，堆是占用内存最大的一块。我们平常的-Xmx、-Xms等参数，就是针对于堆进行设计的。

堆：JVM堆中的数据，是共享的，是占用内存最大的一块区域
虚拟机栈：Java虚拟机栈，是基于线程的，用来服务字节码指令的运行
程序计数器：当前线程所执行的字节码的行号指示器
元空间：方法区就在这里，非堆本地内存：其他的内存占用空间

#JVM内存模型1.8
JVM分为两大块：本地内存、JVM虚拟机数据区域
本地内存：
元数据区：方法区的实现，方法区存放虚拟机加载的类信息，静态变量，常量等数据
直接内存：它可以使用Native函数库直接分配堆外内存

JVM虚拟机数据区域：
程序计数器：每个线程一块，指向当前线程正在执行的字节码的行号。如果当前线程执行的是native方法，则其值为null。
本地方法栈：功能与Java虚拟机栈十分相同。区别在于，本地方法栈为虚拟机使用到的native方法服务。
堆：存放对象实例：所有的对象实例及数组，字符串常量都在堆上进行分配。
java虚拟机栈：线程私有，生命周期与线程同进同退。每个Java方法在被调用的时候都会创建一个栈帧，并入栈。一旦完成调用，则出栈。所有的的栈帧都出栈后，线程也就完成了使命。

# java的内存模型（JMM）是什么？
JVM试图定义一种统一的内存模型，能将各种底层硬件及操作系统的内存访问差异进行封装，
使Java程序在不同硬件及操作系统上都能达到相同的并发效果。它分为工作内存和主内存，
线程无法对主存储器直接进行操作，一个线程要和另外一个线程通信，只能通过主存进行交换。

#JVM垃圾回收时候如何确定是垃圾呢？什么是GC Roots?
1、引用计数法
        引用和对象是关联的，如果要操作对象，则必须用引用进行，因此，可以通过引用计数来判断对象是否可以回收。
        如果该对象被引用，计数器加1，不引用减1，如果计数器等于0，我们就认为没有引用指向该对象，可以将该对象回收，
        优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。
        缺点： 无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.
2、可达性分析
    通过一系列GC Roots对象作为起始点搜索，如果在GC Roots和一个对象之间没有可达路径，则认为该对象不在存活
    可作为GC Roots的对象包括：
        虚拟机栈中所引用的对象（本地变量表）
        方法区中类静态属性引用的对象
        方法区中常量引用的对象
        本地方法栈中JNI引用的对象（Native对象）
# JVM 发生OOM原因（内存溢出）
1、Java堆空间
造成原因：
    无法在 Java 堆中分配对象
    吞吐量增加
    应用程序无意中保存了对象引用，对象无法被 GC 回收
    应用程序过度使用 finalizer。finalizer 对象不能被 GC 立刻回收。finalizer 由结束队列服务的守护线程调用，有时 finalizer 线程的处理能力无法跟上结束队列的增长
解决：
    使用 -Xmx 增加堆大小
    修复应用程序中的内存泄漏
2、GC开销超过限制
造成原因：
    Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。
解决方案：
    使用 -Xmx 增加堆大小
    使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制
    修复应用程序中的内存泄漏
3、请求数组大小超过虚拟机限制
造成原因：
    应用程序试图分配一个超过堆大小的数组
解决：
    使用 -Xmx 增加堆大小
    修复应用程序中分配巨大数组的 bug
4、Perm gen 空间（永久代）
Perm gen 空间包含：
    类的名字、字段、方法
    与类相关的对象数组和类型数组
    JIT 编译器优化
当 Perm gen 空间用尽时，将抛出异常。
解决：
    使用 -XX: MaxPermSize 增加 Permgen 大小
    不重启应用部署应用程序可能会导致此问题。重启 JVM 解决
5、Metaspace
造成原因：
    从 Java 8 开始 Perm gen 改成了 Metaspace，在本机内存中分配 class 元数据（称为 metaspace）。如果 metaspace 耗尽，则抛出异常
解决：
    通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小
    取消 -XX: maxmetsspacedize
    减小 Java 堆大小,为 MetaSpace 提供更多的可用空间
    为服务器分配更多的内存
    可能是应用程序 bug，修复 bug
#生产上如何配置垃圾收集器的？
1、首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。
通常，堆空间我会设置成操作系统的2/3（这是想给其他进程和操作系统预留一些时间），超过8GB的堆优先选用G1。
2、其次，我会对JVM进行初步优化。比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。
3、在其次，就是专项优化，主要判断的依据就是系统容量、访问延迟、吞吐量等。我们的服务是高并发的，所以对STW的时间非常敏感。
4、最后，我会通过记录详细的GC日志，来找到这个瓶颈点，
#假如生产环境CPU占用过高，请谈谈你的分析思路和定位。
首先，使用top -H命令获取占用CPU最高的线程，并将它转化为16进制。

然后，使用jstack命令获取应用的栈信息，搜索这个16进制。这样能够方便的找到引起CPU占用过高的具体原因。

#对于JDK自带的监控和性能分析工具用过哪些？
jps：用来显示Java进程；
jstat：用来查看GC；
jmap：用来dump堆；
jstack：用来dump栈；
jhsdb：用来查看执行中的内存信息；
#java的双亲委托机制是什么？
除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载。
这样一层层向上传递，直到祖先们都无法胜任，它才会真正的加载。
#有哪些打破了双亲委托机制的案例
1、Tomcat可以加载自己目录下的class文件，并不会传递给父类的加载器。
2、Java的SPI，发起者是BootstrapClassLoader，BootstrapClassLoader已经是最上层的了。它直接获取了AppClassLoader进行驱动加载，和双亲委派是相反的。。
比如SPI（JDBC驱动加载），OSGI等。
#简单描述一下（分代）垃圾回收的过程
分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。
新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：
    当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下：
    1、在Eden区执行了第一次GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称from）
    2、Eden区再次GC，这时会采用复制算法，将Eden和from区一起清理。存活的对象会被复制到to区。接下来，只需要清空from区就可以了
#CMS都有哪些问题
（1）内存碎片问题。Full GC的整理阶段，会造成较长时间的停顿。
（2）需要预留空间，用来分配收集阶段产生的“浮动垃圾“。
（3）使用更多的CPU资源，在应用运行的同时进行堆扫描。
（4）停顿时间是不可预期的。

正因为有这些问题，所以大家才用更加完备的G1。况且，现在都是大内存时代了，G1玩得转，就没必要用CMS。
#你都使用G1垃圾回收器的那几个重要参数
最重要的是MaxGCPauseMillis，可以通过它设定G1的目标停顿时间，它会尽量的去达成这个目标。G1HeapRegionSize可以设置小堆区的大小，一般是2的次幂。

InitiatingHeapOccupancyPercent，启动并发GC时的堆内存占用百分比。G1用它来触发并发GC周期，基于整个堆的使用率，而不只是某一代内存的使用比例，默认是45%。
#GC日志的real,user,sys是什么意思
real 实际花费的时间，指的是从开始到结束所花费的时间。比如进程在等待I/O完成，这个阻塞时间也会被计算在内。
user 指的是进程在用户态（User Mode）所花费的时间，只统计本进程所使用的时间，是指多核
sys 指的是进程在核心态（Kernel Mode）花费的CPU时间量，指的是内核中的系统调用所花费的时间，只统计本进程所使用的时间。

#什么情况会造成元空间溢出？
元空间（Metaspace）默认是没有上限的，不加限制比较危险。当应用中的Java类过多，
比如Spring等一些使用动态代理的框架生成了很多类，如果占用空间超出了我们的设定值，就会发生元空间溢出。
所以，默认风险大，但如果你不给足它空间，它也会溢出。
#HashMap中的key，可以是普通对象么？需要什么注意的地方？
Map的key和value都可以是任何类型。但要注意的是，一定要重写它的equals和hashCode方法，否则容易发生内存泄漏。
#对象是怎么从年轻代进入老年代的？
1、超出某个大小的对象将直接在老年代分配。
2、如果对象够老，超过15
3、分配担保。当 Survivor 空间不够的时候，就需要依赖其他内存（指老年代）进行分配担保。这个时候，对象也会直接在老年代上分配。
#MinorGC，MajorGC、FullGC都什么时候发生？
MinorGC在年轻代空间不足的时候发生，MajorGC指的是老年代的GC（标记清除），出现MajorGC一般经常伴有MinorGC。
FullGC有三种情况。
    当老年代无法再分配内存的时候
    元空间不足的时候
    显示调用System.gc的时候。另外，像CMS一类的垃圾回收器，在MinorGC出现promotion failure的时候也会发生FullGC
#什么情况下会发生栈溢出？
栈的大小可以通过-Xss参数进行设置，当递归层次太深的时候，就会发生栈溢出。比如循环调用，递归等。

#cms碎片整理
-XX:+UseCMSCompactAtFullCollection  强制进行空间碎片整理
CMS 采用标记算法，会产生大量的空间碎片。以上参数就是强制执行一次空间碎片整理，但是空间碎片整理会引发STW。
-XX:+CMSFullGCsBeforeCompaction 配置经过几次的FullGC进行空间碎片整理
-XX:+CMSFullGCsBeforeCompaction=10  经过10次FGC后进行空间碎片整理，以降低STW次数