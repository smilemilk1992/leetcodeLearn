# Synchronized有用过吗？谈谈你对它的理解
Synchronized是Java的关键词，JVM实现的一种可以实现并发产生的多个线程互斥同步访问共享资源的方式，
也可以说是一种 “同步互斥锁”，在实际代码中可用于修饰代码块、方法、静态方法以及类；
适用于单体应用系统架构

#说一说Synchronized它的原理？
通过查看被Synchronized 修饰过的代码块编译后的字节码，
会发现编译器会在 被Synchronized修饰过的代码块的前、后生成两个字节码指令：monitorenter、monitorexit；
这两个字节码指令的含义：当JVM执行到monitorenter指令时，
首先会尝试着先获取对象（共享资源）的锁，如果该对象没有被锁定、又或者当前线程已经拥有了这个对象的锁时，
则锁的计数器count加1，即执行 +1 操作；当JVM执行monitorexit指令时，则将锁的计数器count减一，即执行 -1 操作；
当计数器count为0时 ，该对象的锁就被释放了！！
如果当前线程获取该对象的锁失败了，则进入堵塞等待状态，直到该对象的锁被另外一个线程释放为止；
即Java中的Synchronize底层其实是通过对象（共享资源）头、尾设置标记，从而实现锁的获取和释放。

# 什么叫可重入锁，为什么说Synchronized是可重入锁？
通俗地讲，“可重入”指的是：当前线程获取到了当前对象的锁之后，如果后续的操作仍然需要获取获取该对象的锁时，可以不用再次重新获取，即可以直接操作该对象（共享资源）；
可重入性是锁的一个基本要求，是为了解决自己锁死自己的情况，比如一个类的同步方法调用另一个同步方法时，假如Synchronized不支持重入，
进入method2方法时当前线程已经获得锁，而在method2方法里面执行method1时当前线程又要去尝试获取锁，这时如果不支持重入，它就要等待释放，把自己阻塞，导致很有可能自己锁死自己！
对Synchronized来说，可重入性是显而易见的，刚才提到，在执行monitorenter指令时，如果这个对象没有锁定，
或者当前线程已经拥有了这个对象的锁，就把锁的计数器+1，其实本质上就是通过这种方式实现了可重入性（而不是已拥有了锁则不能继续获取）。

# 说一说JVM底层对Java的原生锁做了哪些优化？
而现代JDK中还提供了三种不同的Monitor实现，也就是三种不同的锁：偏向锁、轻量级锁、重量级锁。
这三种锁使得JDK得以优化Synchronized的运行，当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这就是锁的升级、降级。
当没有竞争出现时，默认使用偏向锁，JVM会利用CAS操作，在对象头上的MarkWord部分设置线程ID，以表示这个对象偏向于当前线程，
所以并不涉及真正的互斥锁，因为在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏向锁可以降低无竞争开销。
如果有另一线程试图锁定某个被偏向锁锁过的对象，JVM就会自动撤销偏向锁，切换到轻量级锁实现；轻量级锁依赖CAS操作MarkWord来试图获取锁，
如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁；

#Synchronized是公平锁还是非公平锁，为什么？
非公平；非公平主要表现在获取锁的行为上：并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，
任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象；

#为什么说Synchronized是悲观锁？
因为Synchronized的并发策略是悲观的：即不管是否会产生竞争，任何的数据操作都必须要加锁，包括“从用户态切换到核心态”、“维护锁计数器”和“检查被阻塞的线程是否需要被唤醒”等操作；

# 那你了解乐观锁吗，它的实现原理又是什么，能讲讲吗？（聊聊CAS）
乐观锁，顾名思义表示系统总是认为当前的并发情况是乐观的，而不需要通过加各种锁进行控制；
乐观锁的实现原理是CAS机制（Compare And Swap，比较并交换），一种在JUC中广泛使用的算法；它涉及到三个操作数：内存值V、预期值A、新值B，
当且仅当预期值A和内存值V相等时才将内存值V修改为新值B；
其底层实现逻辑：首先检查某块内存的值是否跟之前我读取的是一样的，如果不一样则表示期间此内存值已经被别的线程更改过，
舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存，即间接意味着获取锁成功！
CAS具有原子性，它的原子性是由CPU硬件指令实现保证的，即通过JNI调用Native方法，从而调用由C++编写的硬件级别指令，
JDK中提供了Unsafe类来执行这些操作（查看JUC很多类的底层源码会发现 Unsafe.compareAndSwapxxx() 的调用无处不在，很牛逼！！！）

# 乐观锁就一定是好的吗？（自旋消耗性能以及ABA的问题）
乐观锁可以避免 悲观锁独占对象这一现象 的出现，同时也提高了并发性能，但它也有一些缺点：
A. 乐观锁只能保证一个共享变量的原子操作：如果多个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小；
B. 长时间自旋可能导致开销大。假如CAS长时间不成功而一直自旋，会给CPU带来很大的开销；
C. ABA问题：CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不够严谨；
假如内存值原来是A，后来被一线程改为B，最后又被改回了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。

# ABA问题有什么办法解决吗？
解决的思路是引入版本号，每次变量更新时都把版本号加1，同时如果条件允许，还需要额外建立数据更新历史表，并同时维护好版本号version 和 数据变更记录的映射关系！

#跟Synchronized相比，可重入锁ReentrantLock的实现原理有什么不同？
synchronized 属于独占式悲观锁，是通过 JVM 隐式实现的，synchronized 只允许同一时刻只有一个线程操作资源。
在 Java 中每个对象都隐式包含一个 monitor（监视器）对象，加锁的过程其实就是竞争 monitor 的过程，当线程进入字节码 monitorenter 指令之后，
线程将持有 monitor 对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor 对象时，则需要阻塞等待获取该对象。

ReentrantLock 是 Lock 的默认实现方式之一，它是基于 AQS（Abstract Queued Synchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，
在它的内部有一个 state 的状态字段用于表示锁是否被占用，如果是 0 则表示锁未被占用，此时线程就可以把 state 改为 1，并成功获得锁，
而其他未获得锁的线程只能去排队等待获取锁资源。
ReentrantLock的基本实现可以概括为：先通过CAS尝试获取锁。如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：
非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；
公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁。


其实，几乎所有锁的实现原理都是为了达到同个目的：让所有的线程都能看到某种标记，同一时刻只能有一个线程获取到锁；
Synchronized通过在对象头中设置标记MarkWord实现了这一目的，是一种JVM原生的锁实现方式；
而ReentrantLock以及所有的基于Lock接口的实现类，则是通过一个volitile关键字修饰的int类型变量，
并保证每个线程都能拥有对该int变量的可见性和原子性，其本质是基于所谓的AQS框架；

#谈谈AQS
1、AQS，即 AbstractQueuedSynchronizer 抽象队列同步器，是一个用来构建锁和同步器的类，JUC Lock包下的锁（常用的有ReentrantLock、ReadWriteLock），
以及其他的像Semaphore、CountDownLatch，甚至是早期的FutureTask等，都是基于AQS来构建的；

2、AQS在内部定义了一个变量：volatileint state，用于表示同步状态：当线程调用lock方法时，如果state=0，说明没有任何线程占有共享资源的锁，
可以获得锁并将state=1；如果state=1，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。

3、AQS内部是通过Node实体类来表示一个双向链表结构的同步队列，完成线程获取锁的排队工作，当有线程获取锁失败后，就被添加到队列末尾。

4、AQS通过内部类ConditionObject构建等待队列（可有多个），当Condition调用wait()方法后，线程将会加入等待队列中，
而当Condition调用signal()方法后，线程将从等待队列转移动同步队列中竞争锁。

5、AQS和Condition各自维护了不同的队列，在使用Lock和Condition的时候，其实就是两个队列的互相移动。

#对比下Synchronized 和 ReentrantLock的异同？
ReentrantLock是Lock的实现类，是一个互斥的同步锁；
1、从功能角度上看，ReentrantLock比Synchronized的同步操作更精细（因为可以像普通对象一样使用），甚至实现了Synchronized没有的高级功能，如：
    等待可中断
    带超时的获取锁尝试
    可以响应中断请求
    可以实现公平锁
2、从性能角度上看，Synchronized早期实现比较低效，对比ReentrantLock，大多数场景性能都相差较大，但是在Java6中对其进行了非常多的改进，
在竞争不激烈时，Synchronized的性能要优于ReetrantLock；在高竞争情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态。

# 上面提到ReentrantLock也是一种可重入锁，那它的底层又是如何实现的？
ReentrantLock内部自定义了同步器Sync，其实就是加锁的时候通过CAS算法，将线程对象放到一个双向链表中，
每次获取锁的时候，看下当前维护的那个线程ID和当前请求的线程ID是否一样，一样就可重入了。

#除了Synchronized 和 ReentrantLock，你还接触过JUC下中的哪些并发工具？
A.提供了CountDownLatch、CyclicBarrier、Semaphore等，比Synchronized更加高级，可以实现更加丰富多线程操作的同步结构;

B.提供了ConcurrentHashMap、有序的ConcunrrentSkipListMap，或者通过类似快照机制实现线程安全的动态数组CopyOnWriteArrayList等，各种线程安全的容器;

C.提供了ArrayBlockingQueue（`ArrayBlockingQueue` 是一个先进先出的有界队列，初始化容量后，无法进行修改）、
LinkedBlockingQueue（是一个单向链表实现的阻塞队列。该队列按 FIFO（先进先出）排序元素，新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。
链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。）、
SynchorousQueue或针对特定场景的PriorityBlockingQueue（无边界队列）等，各种并发队列的实现；

D.强大的Executor框架，可以创建各种不同类型的线程池，调度任务运行等。

#简单说一说ReadWriteLock 和StampedLock 吧？
虽然ReentrantLock和Synchronized简单实用，但是行为上有一定的局限性，要么不占，要么独占；在实际应用场景中，有时候不需要大量竞争的写操作，
而是以并发读为主，为了进一步优化并发操作的粒度，Java提供了读写锁；
读写锁基于的原理是：多个读操作不需要互斥，如果读锁试图锁定时，写锁却被某个线程持有时，读锁将无法获得，而只好等待对方操作结束，这样就可以自动保证不会读取到脏数据；
ReadWriteLock代表了一对锁，它在数据量大 且 并发读多、写少的时候，能够比纯同步版本凸显出优势；
读写锁看起来比Synchronized的粒度似乎细一些，但在实际应用中，其表现也并不尽人意，主要还是因为相对比较大的开销；
所以，JDK在后期引入了StampedLock，在提供类似读写锁的同时，还支持优化读模式，优化读是基于这样的假设：大多数情况下读操作并不会和写操作冲突，
其逻辑是先试着修改，然后通过validate方法确认是否进入了写模式，如果没有进入，就成功避免了开销；如果进入，则尝试获取读锁。

# 如何让Java的线程彼此同步？你了解过哪些同步器？
JUC 同步器的三个成员 ：CountDownLatch、 CyclicBarrier和 Semaphore

CountDownLatch 是一   次性的，CyclicBarrier 是可循环利用的
CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。
CyclicBarrier 参与的线程职责是一样的。

# synchronized底层原理(wait/notify)
java虚拟机中的synchronized是基于进入和退出monitor对象实现的，
同步分为显式同步和隐式同步，同步代码块代表着显式同步，指的是有明确的monitorenter和monitorexit指令。
同步方法代表着隐式同步，同步方法是由方法调用指令读取运行时常量池中方法的ACC_SYNCHRONIZED标志来隐式实现的。
代码块字节码：
    会发现编译器会在 被Synchronized修饰过的代码块的前、后生成两个字节码指令：monitorenter、monitorexit；
    这两个字节码指令的含义：当JVM执行到monitorenter指令时，
    首先会尝试着先获取对象（共享资源）的锁，如果该对象没有被锁定、又或者当前线程已经拥有了这个对象的锁时，
    则锁的计数器count加1，即执行 +1 操作；当JVM执行monitorexit指令时，则将锁的计数器count减一，即执行 -1 操作；
    当计数器count为0时 ，该对象的锁就被释放了！！
    如果当前线程获取该对象的锁失败了，则进入堵塞等待状态，直到该对象的锁被另外一个线程释放为止；
    即Java中的Synchronize底层其实是通过对象（共享资源）头、尾设置标记，从而实现锁的获取和释放。
    代码中每次调用 monitorenter 必须执行对应的 monitorexit 指令。为了保证这一点，编译器会自动生成一个异常处理器，
    这个异常处理器的目的就是为了同步代码块抛出异常时能执行 monitorexit。这也是字节码中，只有一个 monitorenter 却有两个 monitorexit 的原因。
方法级别的字节码：
    descriptor: ()V
    flags: ACC_PUBLIC（代表public修饰）, ACC_SYNCHRONIZED（指明改方法为同步方法）
    jvm通过判断ACC_SYNCHRONIZED访问标志来判别一个方法是否是同步方法，进而获取monitor对象，
    如果是，执行线程会先尝试获取锁。如果是实例方法，JVM 会尝试获取实例对象的锁，
    如果是类方法，JVM 会尝试获取类锁。在同步方法完成以后，不管是正常返回还是异常返回，都会释放锁。
# lock锁底层原理-自旋+CAS Condition wait  signal
简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。
它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。
1、lock的存储结构：一个int类型状态值（用于锁的状态变更），一个双向链表（用于存储等待中的线程）
2、lock获取锁的过程：本质上是通过CAS来获取状态值修改，如果当场没获取到，会将该线程放在线程等待链表中。
3、lock释放锁的过程：修改状态值，调整等待链表
可以看到在整个实现过程中，lock大量使用CAS+自旋。因此根据CAS特性，lock建议使用在低锁冲突的情况下。
目前java1.6以后，官方对synchronized做了大量的锁优化（偏向锁、自旋、轻量级锁）。因此在非必要的情况下，建议使用synchronized做同步操作。

LockSupport的park()和unPark()方法是native方法，可以阻塞，唤醒线程；
#volatile相关
volatile写的内存语义如下：
    当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。
volatile读的内存语义如下：
    当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。
锁释放的内存语义如下：
     当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。
锁获取的内存语义如下：
     当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须要从主内存中读取共享变量。  
#java concurrent包下的东东
1、java内存模型
    JMM就使用happens-before的概念来阐述多线程之间的内存可见性。
    描述了线程内存与主存见的通讯关系。定义了线程内的内存改变将怎样传递到其他线程的规则，同样也定义了线程内存与主存进行同步的细节，也描述了哪些操作属于原子操作及操作间的顺序。
    代码顺序规则：
        一个线程内的每个动作happens-before同一个线程内在代码顺序上在其后的所有动作.
        传递性：
            如果A happens-before B, B happens-before C, 那么A happens-before C.   
    volatile变量规则：
        对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入
    happens-before原则定义如下：
        1、如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
        2、两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。

# lock与synchronized两者区别
1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
#synchronized底层实现
原子性：synchronized保证语句块内操作是原子的
可见性：synchronized保证可见性（通过“在执行unlock之前，必须先把此变量同步回主内存”实现）
有序性：synchronized保证有序性（通过“一个变量在同一时刻只允许一条线程对其进行lock操作”）
锁代码块：
会发现编译器会在 被Synchronized修饰过的代码块的前、后生成两个字节码指令：monitorenter、monitorexit；
    这两个字节码指令的含义：当JVM执行到monitorenter指令时，
    首先会尝试着先获取对象（共享资源）的锁，如果该对象没有被锁定、又或者当前线程已经拥有了这个对象的锁时，
    则锁的计数器count加1，即执行 +1 操作；当JVM执行monitorexit指令时，则将锁的计数器count减一，即执行 -1 操作；
    当计数器count为0时 ，该对象的锁就被释放了！！
    如果当前线程获取该对象的锁失败了，则进入堵塞等待状态，直到该对象的锁被另外一个线程释放为止；
    即Java中的Synchronize底层其实是通过对象（共享资源）头、尾设置标记，从而实现锁的获取和释放。
    代码中每次调用 monitorenter 必须执行对应的 monitorexit 指令。为了保证这一点，编译器会自动生成一个异常处理器，
    这个异常处理器的目的就是为了同步代码块抛出异常时能执行 monitorexit。这也是字节码中，只有一个 monitorenter 却有两个 monitorexit 的原因。
锁方法：
jvm通过判断ACC_SYNCHRONIZED访问标志来判别一个方法是否是同步方法，进而获取monitor对象，
    如果是，执行线程会先尝试获取锁。如果是实例方法，JVM 会尝试获取实例对象的锁，
    如果是类方法，JVM 会尝试获取类锁。在同步方法完成以后，不管是正常返回还是异常返回，都会释放锁。
#Lock底层实现
CAS+AQS(state+CLH队列)
这里就是通过CAS（乐观锁）去修改state的值(锁状态值)。lock的基本操作还是通过乐观锁来实现的。没有获取到锁就加入上面锁的双向队列，通过自旋，判断当前队列节点是否可以获取到锁
Lock底层实现基于AQS实现，采用线程独占的方式，在硬件层面依赖特殊的CPU指令（CAS）。
#volatile底层实现
在JVM底层volatile是采用“内存屏障”来实现的。
JMM就使用happens-before的概念来阐述多线程之间的内存可见性。
    描述了线程内存与主存见的通讯关系。定义了线程内的内存改变将怎样传递到其他线程的规则，同样也定义了线程内存与主存进行同步的细节，也描述了哪些操作属于原子操作及操作间的顺序。
    代码顺序规则：
        一个线程内的每个动作happens-before同一个线程内在代码顺序上在其后的所有动作.
        传递性：
            如果A happens-before B, B happens-before C, 那么A happens-before C.   
    volatile变量规则：
        对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入
    happens-before原则定义如下：
        1、如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
        2、两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。
#AQS
类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...。
它维护了一个volatile int state(代表共享资源)和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）
AQS定义两种资源共享方式：
1、独占：只有一个线程能执行，如ReentrantLock
2、共享：多个线程可同时执行，如Semaphore/CountDownLatch
自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。