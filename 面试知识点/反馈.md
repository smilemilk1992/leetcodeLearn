https://blog.csdn.net/zhengchao1991/article/details/104743408
1、spring，springboot 与 springmvc有什么区别！
    1、
    Springboot是一个微服务框架，延续了spring框架的核心思想IOC和AOP，简化了应用的开发和部署。
    Spring Boot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。
    提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题--->习惯大于约定。
    -----
    Spring Boot中的一些特点：
    创建独立的spring应用。
    嵌入Tomcat, Jetty，Undertow 而且不需要部署他们。
    提供的“starters” poms来简化Maven配置
    尽可能自动配置spring应用。
    提供生产指标,健壮检查和外部化配置
    绝对没有代码生成和XML配置要求。
    
    .简单理解为：Spring包含了SpringMVC，而SpringBoot又包含了Spring或者说是在Spring的基础上做得一个扩展。
    
    Spring Boot 对比Spring的一些优点包括：
    提供嵌入式容器支持
    使用命令java -jar独立运行jar
    在外部容器中部署时，可以选择排除依赖关系以避免潜在的jar冲突
    部署时灵活指定配置文件的选项
    用于集成测试的随机端口生成
    
    总结：Spring Boot只是Spring本身的扩展，使开发，测试和部署更加方便。

2、dubbo 和springcloud区别！
    SpringCloud是Apache旗下的Spring体系下的微服务解决方案
    Dubbo是阿里系的分布式服务治理框架

    从框架目标来讲dubbo只是一个分布式服务调用的框架，而spring cloud所着眼的是整个微服务体系，
    包含了分布式配置、服务注册与发现、服务路由、服务调用、服务跟踪、断路保护、消息总线、批量任务等等。
    dubbo本身只提供了服务治理的功能，而其他组件是第三方开源实现，而不像spring提供了一站式集成。

3、kafka与zk关系
    1、进行所有Broker的管理
    2.生产者负载均衡
    3.消费者的负载均衡和生产负载均衡类似
    4.记录消息分区于消费者的关系，都是通过创建修改zookeeper上相应的节点实现
    5.记录消息消费进度Offset记录，都是通过创建修改zookeeper上相应的节点实现

4、springcloud 的zuul Feign Ribbon 区别
ribbon/feign是对服务之间调用做负载，是服务之间的负载均衡。

zuul是可以对外部请求做负载均衡。 还可以做统一的降级、限流、认证授权、安全，等等。

5、Rest和RPC对比
    1、RPC最主要的缺陷就是服务提供方和调用方式之间依赖太强,我们需要为每一个微服务进行接口的定义,并通过持续继承发布,需要严格的版本控制才不会出现服务提供和调用之间因为版本不同而产生的冲突
    2、而REST是轻量级的接口,服务的提供和调用不存在代码之间的耦合,只是通过一个约定进行规范,
    所以REST在分布式环境下比RPC更加灵活

6、SpringBoot和SpringCloud
    SpringBoot是Spring推出用于解决传统框架配置文件冗余,装配组件繁杂的基于Maven的解决方案,旨在快速搭建单个微服务
    而SpringCloud专注于解决各个微服务之间的协调与配置,服务之间的通信,熔断,负载均衡等
    技术维度并相同,并且SpringCloud是依赖于SpringBoot的,而SpringBoot并不是依赖与SpringCloud,甚至还可以和Dubbo进行优秀的整合开发
    总结:
    SpringBoot专注于快速方便的开发单个个体的微服务
    SpringCloud是关注全局的微服务协调整理治理框架,整合并管理各个微服务,为各个微服务之间提供,配置管理,服务发现,断路器,路由,事件总线等集成服务
    SpringBoot不依赖于SpringCloud,SpringCloud依赖于SpringBoot,属于依赖关系
    SpringBoot专注于快速,方便的开发单个的微服务个体,SpringCloud关注全局的服务治理框架

7、Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别
    CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。
    CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾
    
    1.ZooKeeper保证的是CP,Eureka保证的是AP
    ZooKeeper在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的
    Eureka各个节点是平等关系,只要有一台Eureka就可以保证服务可用,而查询到的数据并不是最新的
    自我保护机制会导致
    Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务
    Eureka仍然能够接受新服务的注册和查询请求,但是不会被同步到其他节点(高可用)
    当网络稳定时,当前实例新的注册信息会被同步到其他节点中(最终一致性)
    Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪
    2.ZooKeeper有Leader和Follower角色,Eureka各个节点平等
    3.ZooKeeper采用过半数存活原则,Eureka采用自我保护机制解决分区问题
    4.Eureka本质上是一个工程,而ZooKeeper只是一个进程

8、什么是服务熔断?什么是服务降级
    在复杂的分布式系统中,微服务之间的相互调用,有可能出现各种各样的原因导致服务的阻塞,在高并发场景下,服务的阻塞意味着线程的阻塞,导致当前线程不可用,服务器的线程全部阻塞,
    导致服务器崩溃,由于服务之间的调用关系是同步的,会对整个微服务系统造成服务雪崩
    为了解决某个微服务的调用响应时间过长或者不可用进而占用越来越多的系统资源引起雪崩效应就需要进行服务熔断和服务降级处理。
    所谓的服务熔断指的是某个服务故障或异常一起类似显示世界中的“保险丝"当某个异常条件被触发就直接熔断整个服务，而不是一直等到此服务超时。
    服务熔断就是相当于我们电闸的保险丝,一旦发生服务雪崩的,就会熔断整个服务,通过维护一个自己的线程池，当检测到该节点微服务调用响应正常后恢复调用链路。
    熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。
    当检测到该节点微服务调用响应正常后恢复调用链路。
    在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。
    熔断机制的注解是@HystrixCommand。
    服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然水平下降，但好歹可用，比直接挂掉强。

9、微服务的优缺点分别是什么？说下你在项目中遇到的坑
    优点：
    每一个服务足够内聚,代码容易理解
    开发效率提高,一个服务只做一件事
    微服务是松耦合的,是有功能意义的服务
    
    缺点：
    多服务运维难度,随着服务的增加,运维的压力也在增大
    数据一致性
10、什么是微服务
微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。 

一般情况对于服务依赖的保护主要有以下三种解决方案：

熔断模式：这种模式主要是参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。
隔离模式：这种模式就像对系统请求按类型划分成一个个小岛的一样，当某个小岛被火少光了，不会影响到其他的小岛。例如可以对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源。这种模式使用场景非常多，例如将一个服务拆开，对于重要的服务使用单独服务器来部署，再或者公司最近推广的多中心。
限流模式：上述的熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为预防模式。限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成雪崩效应。

11、Hystrix vs sentinel-https://www.jianshu.com/p/4ec9368c7349
1、Hystrix 的关注点在于以 隔离 和 熔断 为主的容错机制，超时或被熔断的调用将会快速失败，并可以提供 fallback 机制。
2、而 Sentinel 的侧重点在于：
    多样化的流量控制
    熔断降级
    系统负载保护
    实时监控和控制台
 
12、java 里面各种集合类
    集合类型主要有3种：set(集）、list(列表）和map(映射)。
    List:
    ArrayList:底层数据结构使数组结构array，查询速度快，增删改慢，因为是一种类似数组的形式进行存储，因此它的随机访问速度极快；
    LinkedList:底层使用链表结构，增删速度快，查询稍慢；
    Set:
    数据无序且唯一,实现类都不是线程安全的类，解决方案：Set set = Collections.sysnchronizedSet(Set对象);    
    HashSet：是Set接口（Set接口是继承了Collection接口的）最常用的实现类，顾名思义，底层是用了哈希表（散列/hash）算法。其底层其实也是一个数组，存在的意义是提供查询速度，插入的速度也是比较快，但是适用于少量数据的插入操作，判断两个对象是否相等的规则：1、equals比较为true；2、hashCode值相同。要求：要求存在在哈希表中的对象元素都得覆盖equals和hashCode方法。
    LinkedHashSet：继承了HashSet类，所以它的底层用的也是哈希表的数据结构，但因为保持数据的先后添加顺序，所以又加了链表结构，但因为多加了一种数据结构，所以效率较低，不建议使用，如果要求一个集合急要保证元素不重复，也需要记录元素的先后添加顺序，才选择使用LinkedHashSet
    TreeSet：Set接口的实现类，也拥有set接口的一般特性，但是不同的是他也实现了SortSet接口，它底层采用的是红黑树算法（红黑树就是满足一下红黑性质的二叉搜索树：①每个节点是黑色或者红色②根节点是黑色的③每个叶子结点是黑色的④如果一个节点是红色的，那么他的两个子节点是黑色的⑤对每个节点，从该节点到其所有的后代叶子结点的简单路径上，仅包含相同数目的黑色结点，红黑树是许多“平衡”搜索树的一种，可以保证在最坏情况下的基本操作集合的时间复杂度为O(lgn)。普及：二叉搜索树的性质：它或者是一棵空树；或者是具有下列性质的二叉树：若左子树不空，则左子树上所有结点的值均小于它的根结点的值；若右子树不空，则右子树上所有结点的值均大于它的根结点的值；左、右子树也分别为二叉排序树。若子树为空，查找不成功。），要注意的是在TreeSet集合中只能存储相同类型对象的引用。
    Map: 
    HashMap：哈希表的实现原理中，先采用一个数组表示位桶，每个位桶的实现在1.8之前都是使用链表，但当每个位桶的数据较多的时候，链表查询的效率就会不高，因此在1.8之后，当位桶的数据超过阈值（8）的时候，就会采用红黑树来存储该位桶的数据（在阈值之前还是使用链表来进行存储），所以，哈希表的实现包括数组+链表+红黑树，在使用哈希表的集合中我们都认为他们的增删改查操作的时间复杂度都是O(1)的，不过常数项很大，因为哈希函数在进行计算的代价比较高,HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。
    TreeMap：TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。TreeMap 实现了Cloneable接口，意味着它能被克隆。TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。
    TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。
    HashTable:Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value，
13、hashmap不安全的原因

14、mysql相关-https://www.cnblogs.com/williamjie/p/11187470.html


15、AQS
 队列同步器=status+CLH队列

16、Springboot 的启动原理-https://www.cnblogs.com/wushaopei/p/12249944.html
@SpringBootApplication = (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan。
@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制
@Configuration：允许在上下文中注册额外的 bean 或导入其他配置类
@ComponentScan：扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除

    1、springboot优势
        1、编码简单
        2、配置更加简单
        3、部署更加简单 jar启动 不需要应用容器
        
        快速创建一个独立运行的spring项目以及与主流框架集成
        使用嵌入式的servlet容器，应用无需打成war包
        starters自动依赖与版本控制
        大量的自动化配置，简化开发，也可以修改默认值
        无需配置XML，无代码生成，开箱即用
        

17、Dubbo架构