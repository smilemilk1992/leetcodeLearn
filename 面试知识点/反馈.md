https://blog.csdn.net/zhengchao1991/article/details/104743408
1、spring，springboot 与 springmvc有什么区别！
    1、
    Springboot是一个微服务框架，延续了spring框架的核心思想IOC和AOP，简化了应用的开发和部署。
    Spring Boot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。
    提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题--->习惯大于约定。
    -----
    Spring Boot中的一些特点：
    创建独立的spring应用。
    嵌入Tomcat, Jetty，Undertow 而且不需要部署他们。
    提供的“starters” poms来简化Maven配置
    尽可能自动配置spring应用。
    提供生产指标,健壮检查和外部化配置
    绝对没有代码生成和XML配置要求。
    
    .简单理解为：Spring包含了SpringMVC，而SpringBoot又包含了Spring或者说是在Spring的基础上做得一个扩展。
    
    Spring Boot 对比Spring的一些优点包括：
    提供嵌入式容器支持
    使用命令java -jar独立运行jar
    在外部容器中部署时，可以选择排除依赖关系以避免潜在的jar冲突
    部署时灵活指定配置文件的选项
    用于集成测试的随机端口生成
    
    总结：Spring Boot只是Spring本身的扩展，使开发，测试和部署更加方便。

2、dubbo 和springcloud区别！
    SpringCloud是Apache旗下的Spring体系下的微服务解决方案
    Dubbo是阿里系的分布式服务治理框架

    从框架目标来讲dubbo只是一个分布式服务调用的框架，而spring cloud所着眼的是整个微服务体系，
    包含了分布式配置、服务注册与发现、服务路由、服务调用、服务跟踪、断路保护、消息总线、批量任务等等。
    dubbo本身只提供了服务治理的功能，而其他组件是第三方开源实现，而不像spring提供了一站式集成。

3、kafka与zk关系
    1、进行所有Broker的管理
    2.生产者负载均衡
    3.消费者的负载均衡和生产负载均衡类似
    4.记录消息分区于消费者的关系，都是通过创建修改zookeeper上相应的节点实现
    5.记录消息消费进度Offset记录，都是通过创建修改zookeeper上相应的节点实现

4、springcloud 的zuul Feign Ribbon 区别
ribbon/feign是对服务之间调用做负载，是服务之间的负载均衡。

zuul是可以对外部请求做负载均衡。 还可以做统一的降级、限流、认证授权、安全，等等。

5、Rest和RPC对比
    1、RPC最主要的缺陷就是服务提供方和调用方式之间依赖太强,我们需要为每一个微服务进行接口的定义,并通过持续继承发布,需要严格的版本控制才不会出现服务提供和调用之间因为版本不同而产生的冲突
    2、而REST是轻量级的接口,服务的提供和调用不存在代码之间的耦合,只是通过一个约定进行规范,
    所以REST在分布式环境下比RPC更加灵活

6、SpringBoot和SpringCloud
    SpringBoot是Spring推出用于解决传统框架配置文件冗余,装配组件繁杂的基于Maven的解决方案,旨在快速搭建单个微服务
    而SpringCloud专注于解决各个微服务之间的协调与配置,服务之间的通信,熔断,负载均衡等
    技术维度并相同,并且SpringCloud是依赖于SpringBoot的,而SpringBoot并不是依赖与SpringCloud,甚至还可以和Dubbo进行优秀的整合开发
    总结:
    SpringBoot专注于快速方便的开发单个个体的微服务
    SpringCloud是关注全局的微服务协调整理治理框架,整合并管理各个微服务,为各个微服务之间提供,配置管理,服务发现,断路器,路由,事件总线等集成服务
    SpringBoot不依赖于SpringCloud,SpringCloud依赖于SpringBoot,属于依赖关系
    SpringBoot专注于快速,方便的开发单个的微服务个体,SpringCloud关注全局的服务治理框架

7、Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别
    CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。
    CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾
    
    1.ZooKeeper保证的是CP,Eureka保证的是AP
    ZooKeeper在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的
    Eureka各个节点是平等关系,只要有一台Eureka就可以保证服务可用,而查询到的数据并不是最新的
    自我保护机制会导致
    Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务
    Eureka仍然能够接受新服务的注册和查询请求,但是不会被同步到其他节点(高可用)
    当网络稳定时,当前实例新的注册信息会被同步到其他节点中(最终一致性)
    Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪
    2.ZooKeeper有Leader和Follower角色,Eureka各个节点平等
    3.ZooKeeper采用过半数存活原则,Eureka采用自我保护机制解决分区问题
    4.Eureka本质上是一个工程,而ZooKeeper只是一个进程

8、什么是服务熔断?什么是服务降级
    在复杂的分布式系统中,微服务之间的相互调用,有可能出现各种各样的原因导致服务的阻塞,在高并发场景下,服务的阻塞意味着线程的阻塞,导致当前线程不可用,服务器的线程全部阻塞,
    导致服务器崩溃,由于服务之间的调用关系是同步的,会对整个微服务系统造成服务雪崩
    为了解决某个微服务的调用响应时间过长或者不可用进而占用越来越多的系统资源引起雪崩效应就需要进行服务熔断和服务降级处理。
    所谓的服务熔断指的是某个服务故障或异常一起类似显示世界中的“保险丝"当某个异常条件被触发就直接熔断整个服务，而不是一直等到此服务超时。
    
    服务熔断就是相当于我们电闸的保险丝,一旦发生服务雪崩的,就会熔断整个服务,通过维护一个自己的线程池，当检测到该节点微服务调用响应正常后恢复调用链路。
    熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。
    当检测到该节点微服务调用响应正常后恢复调用链路。
    在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。
    熔断机制的注解是@HystrixCommand。
    服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然水平下降，但好歹可用，比直接挂掉强。

9、微服务的优缺点分别是什么？说下你在项目中遇到的坑
    优点：
    每一个服务足够内聚,代码容易理解
    开发效率提高,一个服务只做一件事
    微服务是松耦合的,是有功能意义的服务
    
    缺点：
    多服务运维难度,随着服务的增加,运维的压力也在增大
    数据一致性
10、什么是微服务
微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。 

一般情况对于服务依赖的保护主要有以下三种解决方案：

熔断模式：这种模式主要是参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。
隔离模式：这种模式就像对系统请求按类型划分成一个个小岛的一样，当某个小岛被火少光了，不会影响到其他的小岛。例如可以对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源。这种模式使用场景非常多，例如将一个服务拆开，对于重要的服务使用单独服务器来部署，再或者公司最近推广的多中心。
限流模式：上述的熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为预防模式。限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成雪崩效应。

11、Hystrix vs sentinel-https://www.jianshu.com/p/4ec9368c7349
1、Hystrix 的关注点在于以 隔离 和 熔断 为主的容错机制，超时或被熔断的调用将会快速失败，并可以提供 fallback 机制。
2、而 Sentinel 的侧重点在于：
    多样化的流量控制
    熔断降级
    系统负载保护
    实时监控和控制台
 
12、java 里面各种集合类
    集合类型主要有3种：set(集）、list(列表）和map(映射)。
    List:
    ArrayList:底层数据结构使数组结构array，查询速度快，增删改慢，因为是一种类似数组的形式进行存储，因此它的随机访问速度极快；
    LinkedList:底层使用链表结构，增删速度快，查询稍慢；
    Set:
    数据无序且唯一,实现类都不是线程安全的类，解决方案：Set set = Collections.sysnchronizedSet(Set对象);    
    HashSet：是Set接口（Set接口是继承了Collection接口的）最常用的实现类，顾名思义，底层是用了哈希表（散列/hash）算法。其底层其实也是一个数组，存在的意义是提供查询速度，插入的速度也是比较快，但是适用于少量数据的插入操作，判断两个对象是否相等的规则：1、equals比较为true；2、hashCode值相同。要求：要求存在在哈希表中的对象元素都得覆盖equals和hashCode方法。
    LinkedHashSet：继承了HashSet类，所以它的底层用的也是哈希表的数据结构，但因为保持数据的先后添加顺序，所以又加了链表结构，但因为多加了一种数据结构，所以效率较低，不建议使用，如果要求一个集合急要保证元素不重复，也需要记录元素的先后添加顺序，才选择使用LinkedHashSet
    TreeSet：Set接口的实现类，也拥有set接口的一般特性，但是不同的是他也实现了SortSet接口，它底层采用的是红黑树算法（红黑树就是满足一下红黑性质的二叉搜索树：①每个节点是黑色或者红色②根节点是黑色的③每个叶子结点是黑色的④如果一个节点是红色的，那么他的两个子节点是黑色的⑤对每个节点，从该节点到其所有的后代叶子结点的简单路径上，仅包含相同数目的黑色结点，红黑树是许多“平衡”搜索树的一种，可以保证在最坏情况下的基本操作集合的时间复杂度为O(lgn)。普及：二叉搜索树的性质：它或者是一棵空树；或者是具有下列性质的二叉树：若左子树不空，则左子树上所有结点的值均小于它的根结点的值；若右子树不空，则右子树上所有结点的值均大于它的根结点的值；左、右子树也分别为二叉排序树。若子树为空，查找不成功。），要注意的是在TreeSet集合中只能存储相同类型对象的引用。
    Map: 
    HashMap：哈希表的实现原理中，先采用一个数组表示位桶，每个位桶的实现在1.8之前都是使用链表，但当每个位桶的数据较多的时候，链表查询的效率就会不高，因此在1.8之后，当位桶的数据超过阈值（8）的时候，就会采用红黑树来存储该位桶的数据（在阈值之前还是使用链表来进行存储），所以，哈希表的实现包括数组+链表+红黑树，在使用哈希表的集合中我们都认为他们的增删改查操作的时间复杂度都是O(1)的，不过常数项很大，因为哈希函数在进行计算的代价比较高,HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。
    TreeMap：TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。TreeMap 实现了Cloneable接口，意味着它能被克隆。TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。
    TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。
    HashTable:Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value，
13、hashmap不安全的原因

14、mysql相关-https://www.cnblogs.com/williamjie/p/11187470.html


15、AQS
 队列同步器=status+CLH队列

16、Springboot 的启动原理-https://www.cnblogs.com/wushaopei/p/12249944.html
@SpringBootApplication = (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan。
@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制
@Configuration：允许在上下文中注册额外的 bean 或导入其他配置类
@ComponentScan：扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除

    1、springboot优势
        1、编码简单
        2、配置更加简单
        3、部署更加简单 jar启动 不需要应用容器
        
        快速创建一个独立运行的spring项目以及与主流框架集成
        使用嵌入式的servlet容器，应用无需打成war包
        starters(启动器)自动依赖与版本控制
        大量的自动化配置，简化开发，也可以修改默认值
        无需配置XML，无代码生成，开箱即用
        

17、Dubbo架构
    Dubbo 是 基于 Java 的RPC 框架。Dubbo 工作分为 4 个角色，分别是服务提供者、服务消费者、注册中心、和监控中心。
    1、部署阶段中服务提供方在启动时在指定的端口上暴露服务，并向注册中心汇报自己的地址。
    2、服务调用方启动时向注册中心订阅自己感兴趣的服务。
    3、运行阶段注册中心先将地址列表推送给服务消费者，服务消费者选取一个地址向对端发起调用。
    4、在这个过程中，服务消费者和服务提供者的运行状态会上报给监控中心

18、springboot ioc aop
 oop
 AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。
 OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。
 也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。
 对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，
 而不利于各个模块的重用。

 ioc 
    控制反转，它表示让容器管理对象，不用每次都自己取new对象，降低各部分业务逻辑之间的耦合度。使用@Service和@Autowired（通过bytype 类型） 或 @Resource（通过命名by name）提供和使用服务。
    
 aop
    面向切面编程 ，通过动态代理方式实现：
        1、jdk动态代理
        2、Cglib动态代理
    对比：
        JDK动态代理是面向接口的
        CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么抱歉会失败）
    注意：
        如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）
        如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。

19、CMS
-Xmx20g -Xms20g -Xmn5g -XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512m -Xss256k 
-XX:+DisableExplicitGC 
-XX:+UseConcMarkSweepGC 
-XX:+CMSParallelRemarkEnabled 
-XX:CMSFullGCsBeforeCompaction=5 
-XX:+UseCMSCompactAtFullCollection 
-XX:LargePageSizeInBytes=128m 
-XX:+UseFastAccessorMethods 
-XX:+UseCMSInitiatingOccupancyOnly 
-XX:CMSInitiatingOccupancyFraction=70

20、java中String类为什么要设计成final
主要是为了“安全性”和“效率”，因为
1.当String类不能被继承时，就没有机会被修改，可以避免因为继承引起的安全性问题
2.String是jdk提供的核心类，是程序中出现频率较高的类，将其设为final可以提高效率
3、因为java设计者不希望用户定义类去继承String类，所以定义为final类型。final修饰类时，类不可被继承；修饰变量，变量的值不可以被修改；修饰方法，方法不可被子类重写。

21、接口继承和抽象有什么关系吗？
象类和接口都是在一定程度上体现到了java的多态特性。
抽象类：
抽象类提高了类和类的内聚程度，减少了代码量。
抽象类和普通 Java 类在形式上没有太大区别。 
可以有一个或者多个抽象方法，- 抽象类大多用于抽取 Java 类共用方法实现或者共同成员变量。然后通过继承的方式到达代码复用的目的。

接口：
接口降低了类和类的耦合度，但是增加了代码量。

区别：
1、不支持多继承 可以实现多个接口

总结：
继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，
而接口实现则是有没有、具备不具备的关系，比如狗是否能钻火圈，能则可以实现这个接口，不能就不实现这个接口。



22、面向对象设计原则
单一职责原则 ， 类或者对象最好是单一职责，如果发现某个类中承担着多种义务，可以考虑拆分重构。
开闭原则，对扩展是开放的，但是对修改是关闭的。程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已实现。 这样可以减少回归问题。（回归测试）。
里式转换原则， 进程继承抽象时，凡是可以用父类或者基类的地方，都可以用子类转换。简单的说,子类对象可以赋给父类对象，但父类对象不能赋值给子类对象。
接口分离原则，在进行类和接口设计时，如果在一个接口中定义了太多方法，子类可能只需要实现其中部分方法，这样就破坏了程序的内聚性，可采用接口分离方式，进行解耦。这样实现了高内聚，低耦合。
依赖反转，实体应该依赖于抽象而不是实现。也就是说，高层次模块，不应该依赖低层次模块。而是基于抽象接口。抽象接口不应该依赖具体，而具体要依赖于抽象。
    
23、mysql的事务隔离级别
读未提交：一个事务可以读取到另一个事务未提交的修改。这会带来脏读、幻读、不可重复读问题。（基本没用）
读已提交：一个事务只能读取另一个事务已经提交的修改。其避免了脏读，但仍然存在不可重复读和幻读问题。
可重复读：同一个事务中多次读取相同的数据返回的结果是一样的。其避免了脏读和不可重复读问题，但幻读依然存在。
串行化：事务串行执行。避免了以上所有问题。
在MySQL中，默认的隔离级别是REPEATABLE-READ（可重复读），并且解决了幻读问题。简单的来说，mysql的默认隔离级别解决了脏读、幻读、不可重复读问题。

那么MySQL可重复读是如何实现的呢？
    使用的的一种叫MVCC的控制方式 ，即Mutil-Version Concurrency Control,多版本并发控制，类似于乐观锁的一种实现方式
    实现方式：
        InnoDB在每行记录后面保存两个隐藏的列来，分别保存了这个行的创建时间和行的删除时间。这里存储的并不是实际的时间值,而是系统版本号，当数据被修改时，版本号加1
        在读取事务开始时，系统会给当前读事务一个版本号，事务会读取版本号<=当前版本号的数据
        此时如果其他写事务修改了这条数据，那么这条数据的版本号就会加1，从而比当前读事务的版本号高，读事务自然而然的就读不到更新后的数据了
        
24、说一下AOP
25、nacos eureka zookeeper注册中心区别

26、消费者对应的分配partition分区策略
概念：
我们在第一篇文章里分析了kafka存储数据的分区策略，这里对于消费者来说，一个consumer group中有多个consumer，一个 topic有多个partition，
所以肯定会涉及到partition的分配问题，即确定每个partition由哪个consumer来消费，这就是分区分配策略（Partition Assignment Strategy）。

kafka进行分区分配的前提条件：
同一个 Consumer Group 内新增消费者；
订阅的主题新增分区；
消费者离开当前所属的Consumer Group，包括shuts down 或 crashes。

分区分配策略：
Range分配策略（分配不均衡）：
    Range分配策略是面向每个主题的，首先会对同一个主题里面的分区按照序号进行排序，并把消费者线程按照字母顺序进行排序。
    然后用分区数除以消费者线程数量来判断每个消费者线程消费几个分区。如果除不尽，那么前面几个消费者线程将会多消费一个分区。
RoundRobin分配策略（分配不均匀）：
    RoundRobin策略的原理是将消费组内所有消费者以及消费者所订阅的所有topic的partition按照字典序排序，
    然后通过轮询算法逐个将分区以此分配给每个消费者。
    为了保证得均匀的分区分配结果，需要满足两个条件：
        同一个消费者组里的每个消费者订阅的主题必须相同；
        同一个消费者组里面的所有消费者的num.streams必须相等。
    如果无法满足，那最好不要使用RoundRobin分配策略。
Sticky分配策略：
    这种分配策略是在kafka的0.11.X版本才开始引入的，是目前最复杂也是最优秀的分配策略。
    Sticky分配策略的原理比较复杂，它的设计主要实现了两个目的：
        分区的分配要尽可能的均匀；
        分区的分配尽可能的与上次分配的保持相同。


1、 一个消费者组中消费者订阅同一个Topic，每个消费者接受Topic的一部分分区的消息，从而实现对消费者的横向扩展，对消息进行分流。
2、注意：当单个消费者无法跟上数据生成的速度，就可以增加更多的消费者分担负载，每个消费者只处理部分partition的消息，
从而实现单个应用程序的横向伸缩。但是不要让消费者的数量多于partition的数量，此时多余的消费者会空闲。
3、消费者组里面的消费者的数量发生改变的时候（增加/减少消费者），重触发重新分配策略。